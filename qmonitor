#!/usr/local/bin/perl

=head1 NAME

qmonitor - GUI to monitor the status of the JCMT OCS queue

=head1 SYNOPSIS

  qmonitor
  qmonitor -sim

=head1 DESCRIPTION

This is the monitor GUI that complements the new OCS queue (see
L<scuqueue>).

=head1 OPTIONS

The following command-line options are supported:

=over 4

=item B<-sim>

Run the task in simulate mode. When running in this mode no attempt
is made to contact the vax notice board task or the TCS.

=item B<-help>

Print a small help message.

=item B<-man>

Print the full manual page.

=back

=cut

# Simple GUI to display queue status
use 5.006;
use strict;
use warnings;

use subs qw/update_status obeyw DoDramaEvents/;
use subs qw/cutq pasteq startq clearq stopq addback addfront/;
use vars qw/$VERSION/;

use Astro::SLA;
use Astro::Coords;
use Astro::Telescope;
use Time::Piece qw/ :override /;
use File::Spec;

# Need an OMP class for user handling
use lib qw| /jac_sw/omp/msbserver |;
use OMP::General;

# Work out where local software is
use FindBin;
use lib "$FindBin::RealBin/lib";

our $AUDIO_DIR = File::Spec->catdir($FindBin::RealBin,"audio");

# Start up Tk early and put up a status bar

my ($MW, $TKSTATUS, $BAR);

BEGIN {
  $VERSION = '0.11';
  use Tk;
  use Tk::ProgressBar;
  use Tk::Text;

  # Create a new main window
  $MW = MainWindow->new;
  $MW->title('JCMT OCS Queue monitor');
  $MW->iconname('JCMT_Q');

  $TKSTATUS = $MW->Label(qw(-width 40 -anchor w -foreground blue),
                       -text => "QMonitor $VERSION ...");
  $TKSTATUS->grid(-row => 0, -column => 0, -sticky => 'w'); 
  $BAR = $MW->ProgressBar(-from =>0, -to=>100, 
                            -width=>15, '-length'=>270,
                            -blocks => 20, -anchor => 'w',
                            -colors => [0, 'blue'],
                            -relief => 'sunken',
                            -borderwidth => 3,
                            -troughcolor => 'grey',
                           )->grid(-sticky => 's');
  $MW->update;
}

# The FAILURE response GUI
my $FAIL_GUI;

# The MSBDone gui
my $QCOMP_GUI;

# This is the variable associated with ACCEPT/REFUSE
my $ACC_GUI;

# File selection widget
require Tk::FileSelect;
require Tk::DialogBox;
require Tk::LabEntry;
require Tk::NoteBook;

# Read options early so that we can choose targets
# Really Need to be able to preempt the GUI building if we choose -h and -sim
# Get the options
use Getopt::Long;
use Pod::Usage;
my $SIM;
my ($man,$help);
my $status = GetOptions(
			"sim"     => \$SIM,
			"help"    => \$help,
			"man"     => \$man,
		       );

if ($help || $man) {
  $MW->withdraw;
  pod2usage(1)  if ($help);
  pod2usage(-verbose => 2)  if ($man);
}

our ($SCUCD,$NBSTASK,$QNAME);
if ($SIM) {
  $QNAME = "SCUQUEUE";
  $SCUCD = "SCUCD_PERL";
  $NBSTASK = "";
  $MW->title("JCMT OCS Queue monitor - Simulation mode");
} else {
  $QNAME = 'SCUQUEUE@palila'; # Name of Queue task
  $SCUCD = 'SCUCD@SCUVAX';
  $NBSTASK = 'NBS2DRAMA@MWTTEL';
}


update_status 'Loading DRAMA...',5;
eval "use DRAMA::Tk; use DRAMA";
if ($@) {
  die "Error loading DRAMA:\n$@";
}
$DRAMA::MAXREPLIES = 40; # -w
$DRAMA::MAXREPLIES = 40;

update_status 'Loading Qcontrol class',50;
eval "use Queue::Control::DRAMA";
if ($@) {
  die "Error loading Queue::Control::DRAMA:\n$@";
}

update_status 'Loading ODF class',51;
eval "use SCUBA::ODF";
if ($@) {
  die "Error loading SCUBA::ODF:\n$@";
}

update_status 'Loading SrcCatalog class',52;
eval "use Tk::SrcCatalog";
if ($@) {
  die "Error loading Tk::SrcCatalog:\n$@";
}

#use Data::Dumper;

# Define the number of entries stored in QUEUE and PASTE parameters

# DEfine some constants - these are the same as used in the DQueue itseld
# KLUGE - should do this properly
# This should really match the queue
use constant SZSTRING => 100; # Size of strings in Queue parameters

# This one actually governs the size of the Text widget
use constant NENTRIES => 10; # Number of entries in Queue parameters


use constant TASKNAME => "QTK_$$"; # Name of this task

# Monitor variable
# %MONITOR contains the monitored variables
# $TOGGLE is used to determine the state of the START/STOPQ button
# $MORE_INFO is true if we are displaying the MsgOut text window
use vars qw/%MONITOR %NBS_MONITOR $TOGGLE $MORE_INFO/;

$TOGGLE = '---';

$| = 1;

# Initialise DRAMA system
update_status 'Initialise DRAMA',60;
DPerlTkInit(TASKNAME);


# Set the parameters for the Queue::Control::DRAMA class
# May want to import this parameter list from an external list

# $Queue::Control::DRAMA::DEFAULTS = {
#                 OBSMODE => undef,
#                 CENTRE_OFFSET_X => 0,
#                 CENTRE_OFFSET_Y =>  0,
#                 CELL_X => 0,
#                 CELL_Y => 0,
#                 REFERENCE_X => 0,
#                 REFERENCE_Y => 0,
#                 CELL_COORDS => undef,
#                 SOURCE => undef,
#                 AZ_RANGE=> undef,
#                 CENTRE_TYPE => undef,
#                 CAROUSEL_TRACK=> undef,
#                 CATALOG => undef,
#                };

$Queue::Control::DRAMA::QUEUE = $QNAME;
$Queue::Control::DRAMA::QUEUE = $QNAME;


############# G U I   C R E A T I O N ###############################

# Create three frames in top level
# Dont pack them until we are ready

my $Fr1 = $MW->Frame;
my $Fr2 = $MW->Frame;
my $Fr3 = $MW->Frame;
my $Fr4 = $MW->Frame;

# Make sure it is deleted correctly
$MW->protocol('WM_DELETE_WINDOW' => \&shutdown);

# Exit button
update_status 'Creating buttons',75;
$Fr3->Button( -text => 'EXIT', -command => \&shutdown)->pack(-side => 'left');
$Fr3->Button( -textvariable => \$TOGGLE,  -width => 10,-command => \&toggleq
		      )->pack(-side => 'left');
#$Fr3->Button( -text => 'ADD', -command => \&launchFS)->pack(-side => 'left');
$Fr3->Button( -text => 'CLEAR',  -command => \&clearq)->pack(-side => 'left');
$Fr3->Button( -text => 'SUSPEND MSB',  -command => \&suspendmsb)->pack(-side => 'left');
$Fr3->Button( -text => 'ABORT',  -command => \&gui_abort)->pack(-side => 'left');
$Fr3->Button( -text => 'TERMINATE',-command =>\&gui_term)->pack(-side => 'left');
$Fr3->Button( -text => 'EXTEND',-command =>\&gui_extend)->pack(-side => 'left');
#$Fr3->Button( -text => 'REFUSE',-command =>\&gui_refuse)->pack(-side => 'left');

# Create a label for Queue status
$Fr1->Label(-text => 'Queue Status:')->grid(-row => 0,-col=>0,-sticky=>'w');
my $Qstatus = $Fr1->Label(-textvariable => \$MONITOR{STATUS},
			)->grid(-row=>0,-col=>1,-sticky=>'w');

# Integrations status
$Fr1->Label(-text => 'Integrations:')->grid(-row => 1,-col=>0,-sticky=>'w');
my $IntStatus = $Fr1->Label(-textvariable => \$NBS_MONITOR{INT_NUM},
			)->grid(-row=>1,-col=>1,-sticky=>'w');


# SCUCD status
$Fr1->Label(-text => 'SCUCD status:')->grid(-row => 2,-col=>0,-sticky=>'w');
my $ScucdStatus = $Fr1->Label(-textvariable => \$NBS_MONITOR{SCUCD_STAT},
			)->grid(-row=>2,-col=>1,-sticky=>'w');


$Fr1->Label(-text => 'Current entry:')->grid(-row => 3,-col=>0,-sticky=>'w');
my $CurrStatus = $Fr1->Label(-textvariable => \$MONITOR{CURRENT},
			)->grid(-row=>3,-col=>1,-sticky=>'w');

$Fr1->Label(-text => 'Time on Queue (minutes):')->grid(-row => 4,-col=>0,-sticky=>'w');
my $TimeOnQueue = $Fr1->Label(-textvariable => \$MONITOR{TIMEONQUEUE},
			)->grid(-row=>4,-col=>1,-sticky=>'w');



update_status 'Creating listboxes',85;
# Create listbox in frame 2
$Fr2->Label(-text => 'Queue contents')->grid(-row=>0,-col=>1);


#my $ContentsBox = $Fr2->ScrlListbox(-height => NENTRIES, 
#			     -width  => SZSTRING,
#			     -selectmode => 'single',
#			       )->grid(-row=>1,-col=>1);

my $ContentsBox = $Fr2->Scrolled('Text',
				 -scrollbars => 'e',
				 -wrap => 'none',
				 -height => NENTRIES, 
				 -width  => SZSTRING,
		#		 -state  => 'disabled',
			       )->grid(-row=>1,-col=>1);

$ContentsBox->bindtags(qw/widget_demo/);        # remove all bindings but dummy "widget_



# Setup a Text widget that will take all the output sent to MsgOut

$MORE_INFO = 0;

my $MsgText = $Fr4->Scrolled('Text',-scrollbars=>'w',
			     -height=>16,
			     -width=>100,
			    );

my $MsgBut = $Fr4->Checkbutton(-variable => \$MORE_INFO,
			       -text     => 'Info messages...',
			       -command => [\&show_info, $MsgText],
			      )->grid(-row=>0,-col=>1,-sticky=>'w');


# print information to this text widget
Dits::UfacePutMsgOut( sub {
			write_info_message( $MsgText, $_[0] );
		      },
		      new DRAMA::Status);



# Set up a monitor - assumes that the QUEUE is running already
update_status 'Setting up monitor',95;

# These variables record whether or not we have an active monitor
# configured. 0 = we are running, 1 = it has been cancelled somehow
my $NBS_CANCELLED = 1; # for nbs monitor
my $QUEUE_CANCELLED = 1; # For queue monitor

# Kick them off
&check_monitors($MW,30);

# Destroy the progress bar
destroy $TKSTATUS if Exists($TKSTATUS);
destroy $BAR      if Exists($BAR);

# Ask for the OMP user ID
my $OMP_User_Obj = OMP::General->determine_user( $MW );
my $OMP_User;
$OMP_User = $OMP_User_Obj->userid if defined $OMP_User_Obj;

# Finally, pack frames into top frame and enter main loop
$Fr1->grid(-row => 0, -col =>0, -sticky=>'w');
$Fr2->grid(-row => 1, -col =>0);
$Fr3->grid(-row => 2, -col =>0);
$Fr4->grid(-row => 3, -col =>0, -sticky=>'w');

#################### M A I N L O O P #####################################

# Start MainLoop;
MainLoop;

exit;


#################### S U B R O U T I N E S ###############################

# Subroutines go here


sub shutdown {

  # Need to release the monitor (unless that has been done already)
  if (exists $MONITOR{MONITOR_ID} || exists $NBS_MONITOR{MONITOR_ID}) {

    if (exists $MONITOR{MONITOR_ID} && ! $QUEUE_CANCELLED) {
      monitor($QNAME, "CANCEL", $MONITOR{MONITOR_ID});
    }
    if ($NBSTASK) {
      if ($NBS_MONITOR{MONITOR_ID} && ! $NBS_CANCELLED) {
	monitor($NBSTASK, "CANCEL", $NBS_MONITOR{MONITOR_ID});
      }
    }
    select undef,undef,undef,0.1; # Wait for any shutdown messages
    DoDramaEvents;
  }
  # Need to clear the MsgOut tie
  Dits::UfacePutMsgOut( undef, new DRAMA::Status);

  # Destroy the window
  destroy $MW if Exists($MW);

  # and exit
  exit;
}


# Convert subroutine - converts the parameter value
# to a value.
# For CURRENT and STATUS do nothing.
# For Queue convert to a hash and return
# Could do this in a trigger routine just as easily...

sub cvtsub {
  my ($param, $value) = @_;

  #print "PARAMETER: $param\n";

  if ($param eq 'STATUS') {
    if ($value =~ /Stop/i) {
      $Qstatus->configure(-background=>'red',-foreground=>'black');
      $TOGGLE = 'STARTQ';
      # beep
      #for (1..5) {print STDOUT "\a"; select undef,undef,undef,0.2}
    } else {
      $Qstatus->configure(-background=>'green',-foreground=>'black');
      $TOGGLE = 'STOPQ';
    }
  } elsif ($param eq 'INDEX') {
    # Set the highlight position
    update_index( $value );
  }
  return $value if not ref($value);

  # Assume we have a Sds
  my %tie;
  tie %tie, "Sds::Tie", $value;

  if ($param eq 'Queue') {

    my %queue = %tie;

    # Strip trailing space and reduce array size
    foreach (@{$queue{'Contents'}}) {
      s/\s+$//;
    }


    # Update the Contents in the listbox
    &update_listboxes(\%queue);

    return \%queue;

  } elsif ($param eq 'FAILURE') {
    # When FAILURE triggers we should obtain the ODF, see what the problem
    # is, pop up a gui to request help.
    # Problem is that you can not do this until the monitor has completed.
    # If you try to do an obey to retrieve the ODF (if we decide not to publish
    # it as part of the FAILURE Sds parameter) you cannot use an "obeyw"
    # you can also not do any Tk event handling. The problem is the monitor
    # must complete before you go into any other event handling. This implies
    # that we have to set a variable from to indicate that FAILURE has returned
    # and then work that out when we enter the event loop. Easiest thing
    # is to do an after() for a few milliseconds later.

    use Data::Dumper;
    print Dumper(\%tie);

    # if we are prompting for changes to the ODF we
    # need to destroy that widget here because this may
    # indicate that someone else has responded or that another
    # problem is requested
    if ($FAIL_GUI) {
      $FAIL_GUI->destroy;
      undef $FAIL_GUI;
    }

    # first check that we have to react
    if (exists $tie{DETAILS}) {

      # Trigger a callback
      $MW->after(1, sub {respond_to_failure($tie{DETAILS})});

    }

  } elsif ($param eq 'MSBCOMPLETED') {

    print "Got MSBCOMPLETED parameter:\n";
    use Data::Dumper;
    print Dumper(\%tie);

    # Always delete the window if it is up since the details might
    # be different
    if ($QCOMP_GUI) {
      print "Removing pre-existing GUI\n";
      $QCOMP_GUI->destroy;
      undef $QCOMP_GUI;
    }

    # first check that we have to react
    if (keys %tie) {
      # Trigger a callback
      print "Got keys, so instantiating window\n";
      $MW->after(1, sub { respond_to_qcomplete(\%tie)});
    }
  } elsif ($param eq 'MESSAGES') {
    write_info_message( $MsgText, $tie{MESSAGE} );

  }
  return $value;
}

# Write an array of lines into the "Info Messages" text box
# write_info_message( $widget, @lines);
# write_info_message( $widget, \@lines);

sub write_info_message {
  my $w = shift;
  return unless defined $w;
  my @lines;
  if (ref($_[0])) {
    @lines = @{ $_[0] };
  } else {
    @lines = @_;
  }
  clean_array(\@lines);

  # [CODE taken from the TIEHANDLE for Tk::Text - I wrote
  # it anyway]
  # Find out whether 'end' is displayed at the moment
  # Retrieve the position of the bottom of the window as
  # a fraction of the entire contents of the Text widget
  my $yview = ($w->yview)[1];

  # If $yview is 1.0 this means that 'end' is visible in the window
  my $update = 0;
  $update = 1 if $yview == 1.0;

  # Insert the text
  $w->insert('end',join("\n",@lines)."\n");

  # Move to the end
  # Make sure that we do not move to the end if we can not see the end
  $w->see('end') if $update;
}


# Update the contents of the listbox. Usually called when monitor
# updates

sub update_listboxes {
  # Read the hash ref
  my $href = shift;

  # Clear the contents listbox
  $ContentsBox->configure( -state => 'normal');
  $ContentsBox->delete('0.0','end');

  # Remove blank lines from the end of the array
  # Assume that all blank lines are bad
  my @contents = grep { /\w/ } @{$href->{Contents}};

  # Fill it
  my $counter = 0;
  for my $line (@contents) {

    # Take local copy of index for callbacks
    my $index = $counter;

    # Generate the tag name based on the index
    my $dtag = "d" . $index;
    my $ctag = "c" . $index;

    # Get the reference position
    my $start = $ContentsBox->index('insert');

    # insert the line
    $ContentsBox->insert('end', sprintf("%-3d %s",$counter,$line) . "\n");

    # Remove all the tags at this position
    foreach my $tag ($ContentsBox->tag('names', $start)) {
        $ContentsBox->tag('remove', $tag, $start, 'insert');
    }

    # Create a new tag for the highlighter
    $ContentsBox->tag('add', $dtag, $start, 'insert');

    # and configure it 
    $ContentsBox->tag('configure', $dtag, 
#		      -foreground => 'white',
		      -background => 'green',);

    # Now create a new base color tag at higher priority
    # to control the general color. When a highlighter is added the
    # priorities will be raised and the highlighter will dominate
    $ContentsBox->tag('add',$ctag, $start, 'insert');

    # default foreground is black
    my $fgcol = 'black';
    if ($line =~ /SENT/) {
      $fgcol = 'yellow4';
    } elsif ($line =~ /OBSERVED/) {
      $fgcol = 'grey55';
    } elsif ($line =~ /ERROR/) {
      $fgcol = 'red';
    }

    # and configure it
    my $bgcol = "white";
    $ContentsBox->tag('configure', $ctag, 
		      -foreground => $fgcol,
		      -background => $bgcol,);

    # raise it
    $ContentsBox->tagRaise($ctag);

    # bind the tag to button click
    $ContentsBox->tag('bind', $dtag, '<ButtonRelease-1>' =>
		      sub {pset($QNAME,"INDEX", $index)});

    # and to the right mouse button
    $ContentsBox->tag('bind', $dtag, '<Button-2>' =>
		      [ \&ContentsMenu, $index, Ev('X'), Ev('Y')] ,
		     );

    # show the user where there mouse is
    $ContentsBox->tag('bind', $ctag, '<Any-Enter>' =>
                      sub { shift->tag('configure', $ctag,
				       -background => 'yellow',
                                       qw/ -relief raised
                                           -borderwidth 3 /); } );

    $ContentsBox->tag('bind', $ctag, '<Any-Leave>' =>
                      sub { shift->tag('configure', $ctag,
				       -background => $bgcol,
                                       qw/ -relief flat /); } );


    $counter++;
  }

  $ContentsBox->configure( -state => 'disabled');

  # and finally insert the index
  update_index( $MONITOR{INDEX} );

}

# Routine to update the position of the index.
# If no argument is supplied the value is obtained from the drama task
# via a pget
#   update_index( $index );
# Makes sure that the index is visible

sub update_index {
  my $index = shift;

  # First need to configure all the existing tags so that they
  # are not highlighted
  my %tags;
  foreach my $tag ($ContentsBox->tag('names')) {
    if ($tag =~ /^d\d/) {
      $ContentsBox->tagLower($tag);
    } elsif ($tag =~ /^c\d/) {
      $ContentsBox->tagRaise($tag);
    }
    # build up a hash of tag names so that we can guarantee
    # that the tag we use later actually exists
    $tags{$tag} = undef;
  }

  # only do something if we have a value
  if (defined $index) {
    my $dtag = "d" . $index;

    if (exists $tags{$dtag}) {
      # Now set the highlight
      $ContentsBox->tagRaise($dtag);

      # and make it visible (index needs to be incremented by 1
      # here to make sure the line is visible rather than just its
      # top
      $index++;
      $ContentsBox->see("$index.0");
    }
  }
}


# Routine called during an error in the monitor

sub monerror {
  # Flush status
  $_[2]->Flush;
  $QUEUE_CANCELLED = 1;
}

sub nbs_monerror {
  # Flush status
  $_[2]->Flush;
  $NBS_CANCELLED = 1;
}




# Start or stop the queue

sub toggleq {
  if ($MONITOR{STATUS} =~ /^Stop/i) {
#    print "Starting Q\n";
    startq;
  } else {
#    print "Stopping Q\n";
    stopq;
  }

}

# This subroutine updates the display widget on startup

sub update_status {
    my($status_text, $something) = @_;

    $TKSTATUS->configure(-text => "$status_text ...");
    $BAR->value($something);
    $MW->update;
}


# This routine withdraws or shows the MsgOut text widget
# depending on the value of $MORE_INFO.

sub show_info {
  my $w = shift;  # The text widget
  if ($MORE_INFO) {
    $w->grid(-row=>1,-col=>1,-sticky=>'ens');
  } else {
    $w->gridForget;
  }
}


# Routine to launch a file selection widget that can be used
# to add ODFs to the queue

sub launchFS {
  $MW->FileSelect(-transient => 0,
		  -command => \&gui_addq,
		  -selectmode => 'extended',
		  -filelabel => 'Selected ODF File',
		  -filelistlabel => 'ODF files',
		 )->Show;
}


# Routine to actually take the output from the file selector
# and place it in the quueue.
# The location will be the back unless an entry in the queue
# is selected.
# This takes arguments of an array of file names including
# the full path

sub gui_addq {
  my @Odfs = @_;
  return unless scalar(@Odfs) > 0;

  # Read the selection from the listbox
  my @sel = $ContentsBox->curselection;

  print "Selection = @sel\n";

  if (@sel) {
    my $posn = $sel[0] + 1; # Start at 1

    print "PASTING at position $posn\n";

    # Paste to selected position
    pasteq $posn, @Odfs;

  } else {
    print "ADDBACK\n";
    # Paste at end of queue by default
    addback @Odfs;
  }

}


# GUI dealing with responding to a failure of an ODF to load
# because it is missing information
# Arguments are: The ODF, the failure details

sub respond_to_failure {
  my $details = shift;

  #print Dumper($details);

  if ($details->{REASON} eq 'MissingTarget') {
    # Let us try to get the ODF
    my $odf = new SCUBA::ODF( Hash => $details->{ENTRY});

    # First need to inform user of the request
    # (hopefully part of a single window)

    # Now create src catalog object
    # If we are a science observation (PHOTOM, MAP) then
    # the assumption is we are looking for a calibrator
    # (either secondary calibrator or planet)
    # Additionally if we are followed by a calibration observation
    # then we really want to point on it so should reduce the
    # choices to just pointing

    # if we are a POINTING or FOCUS then we need the pointing catalog
    my $cat;
    if ($details->{CAL}) {
      # We want calibrators only
      $cat = new SrcCatalog::JCMT;

      # need to add the planets to this list
      my $tel = new Astro::Telescope( 'JCMT' );
      my @planets = map { new Astro::Coords(planet => $_) }
	qw/ mars uranus saturn jupiter venus /;
      for (@planets) {
	$_->telescope($tel);
      }

      $cat->addSources( @planets, &scuba_2cals() );

    } else {
      # pointing catalog if not a Calibrator
      # This will add the planets automatically
      $cat = new SrcCatalog::JCMT( 'default' );
    }

    # Make sure we only generate observable sources
    $cat->canObserve( 1 );
    $cat->reset;

    # Create object based on AZEL
    # can only do distance if we know where we are now. May require
    # access to the TCS. If we do not have AZ just give everything
    if (exists $details->{AZ}) {
      # Add a reference position if we have one
      my $refcoord = new Astro::Coords(az=> $details->{AZ},
				       el=> $details->{EL},
				       units=>'rad');

      $refcoord->telescope( new Astro::Telescope( 'JCMT' ));

      # convert ISO date to Time::Piece object
      $refcoord->datetime( OMP::General->parse_date( $details->{TIME} ));

      # register the reference position
      $cat->reference( $refcoord );

      # sort by distance
      $cat->sortList('distance');

    } else {
      # simply sort by azimuth
      $cat->sortList('az');
    }

    # play sound
    play_sound('chime.wav');

    # and put up the GUI
    $FAIL_GUI = new Tk::SrcCatalog( $MW,-onDestroy => sub { $FAIL_GUI = undef;},
				    -upDate => sub {},
				    -addCmd => sub {
				      # The actual coordinate (come in as an array)
				      my $arr = shift;
				      my $c = $arr->[0];

				      # if nothing has been selected
				      # must simply do nothing
				      return unless $c;

				      # now reset the gui object
				      undef $FAIL_GUI;

				      print "C is ". $c->status;

				      # Store that coordinate in the
				      # object
				      $odf->setTarget( $c );
				      my %hash = $odf->odf;

				      # Add INDEX field
				      $hash{INDEX} = $details->{INDEX};

				      # add PROPSRC flag
				      $hash{PROPSRC} = "1";

				      my $status = new DRAMA::Status;
				      my $sds = Sds->PutHash( \%hash, "ODF", $status);

				      # and load the ODF back in
				      &DRAMA::obey($QNAME, "REPLACEQ", $sds, { -deletearg => 0,
									      -success => sub {
										&DRAMA::obey($QNAME,"STARTQ");
									      },
									    } );

				    },
				    -catalog => $cat,
				    -transient => 1,
				  );

  } else {
    print "Unable to deal with reason: " . $details->{REASON}. "\n";
    use Devel::Peek;
    my $var = $details->{REASON};
    Dump($var);
  }

}

# Respond to a qompletion request
sub respond_to_qcomplete {
  my $details = shift;

  return unless keys %$details;

  # Since we can have multiple MSB triggers at once we need
  # to create our onw top level rather than a dialog box
  my $gui = $MW->Toplevel(-title => "MSB Accept/Reject");

  my $entry = $gui->LabEntry( -label => "OMP User ID:",
			      -width => 10,
			      -textvariable => \$OMP_User,
			    )->pack(-fill => 'x', -expand => 1);

  # Tabbed notebook
  my $NB = $gui->NoteBook();
  $NB->pack(-fill => 'x', -expand=>1);

  # A tab per MSB request
  foreach my $tstamp (keys %$details) {

    # Create the tab itself
    my $tab = $NB->add( $tstamp, -label => $tstamp);

    # create the tab contents
    &create_msbcomplete_tab( $tab, $tstamp, %{$details->{$tstamp}});

  }

  # Now that we have made the popups we can display them
  # Note that this blocks.
  play_sound('chime.wav');

  # Store the gui reference
  $QCOMP_GUI = $gui;

}

# Create the tab for each MSB in turn

sub create_msbcomplete_tab {
  my $w = shift;
  my $tstamp = shift;
  my %details = @_;

  my $text = "MSB $details{MSBID} of project $details{PROJECTID} has completed.".
 " Please either accept or reject it and enter a reason (if desired)";

  $w->Label( -text => $text,
	     -wraplength=>400)->pack(-side =>'top',-expand => 1,-fill=>'both');


  my $Reason = $w->Text(-height => 5, -width => 50)->pack(-side => 'top');

  # Now add on the buttons on the bottom
  my $butframe = $w->Frame->pack;
  $butframe->Button(-text => "Accept",
		   -command => [ \&msbcompletion, $tstamp, 1, $Reason]
		   )->pack(-side =>'left');
  $butframe->Button(-text => "Reject",
		   -command => [ \&msbcompletion, $tstamp, 0,$Reason]
		   )->pack(-side =>'left');


}

# This is the trigger that actually sends the obey in response
# to an accept/reject. Takes a timestamp an accept/reject flag
# and a reference to the text widget containing the reason (if any)
# Is called once for each MSB - this will cause problems since the
# obey will trigger an update of the parameter...

sub msbcompletion {
  my $tstamp = shift;
  my $accept = shift;
  my $rw = shift;

  my $arg = Arg->Create;
  my $status = new DRAMA::Status;
  $arg->PutString("Argument1",$tstamp, $status);
  $arg->PutString("Argument2",$accept, $status);

  # A user [I could verify it here...]
  $arg->PutString("Argument3", $OMP_User, $status)
    if $OMP_User;

  my $reason = $rw->get( '0.0','end');
  # Make sure we have content
  if (length($reason) > 0 && $reason =~ /\w/) {
    $arg->PutString("Argument4", $reason, $status);
  }

  obey($QNAME,"MSBCOMPLETE",$arg,{-deletearg=>0});

  # need to undefine the gui variable
  # Note that this is strange when we have multiple MSBs
  destroy $QCOMP_GUI;
  undef $QCOMP_GUI;

}

# Return all the SCUBA secondary calibrators
# This really needs to be obtained from a separate class that knows
# about scuba calibration since many systems would like to know
# this information
# Returns Astro::Coords objects as a list:
# Should probably include the planets here!
#    @calcoords = scuba_cals();
sub scuba_2cals {
  my @coords = (
		{
		 name => 'OH231.8',
		 ra => '07 42 16.939',
		 dec => '-14 42 49.05',
		 type => 'J2000',
		},
		{
		 name => 'IRC+10216',
		 ra => '09 47 57.382',
		 dec => '13 16 43.66',
		 type => 'J2000',
		},
		{
		 name => '16293-2422',
		 type => 'J2000',
		 ra => '16 32 22.909',
		 dec => '-24 28 35.60',
		},
		{
		 name => 'HLTau',
		 ra => '04 31 38.4',
		 dec => '18 13 59.0',
		 type => 'J2000',
		},
		{
		 name => 'CRL618',
		 ra => '04 42 53.597',
		 dec => '36 06 53.65',
		 type => 'J2000',
		},
		{
		 name => 'CRL2688',
		 ra => '21 02 18.805',
		 dec => '36 41 37.70',
		 type => 'J2000',
		},

	       );

  my $tel = new Astro::Telescope( 'JCMT' );
  my @c = map { new Astro::Coords( %$_ ) } @coords;
  foreach (@c) { $_->telescope($tel); }
  return @c;
}

# suspend an MSB [should be in Queue::Control::DRAMA]
# at the currently highlighted position

sub suspendmsb {
  &DRAMA::obey($QNAME, "SUSPENDMSB");
}

# Send messages to SCUCD - these messages should be in  a class

sub gui_abort {
  &DRAMA::obey($SCUCD,"ABORT");
}

sub gui_term {
  &DRAMA::obey($SCUCD,"TERMINATE");
}

sub gui_accept {
  my $arg = Arg->Create;
  my $status = new DRAMA::Status;
  $arg->PutString("Argument1","CHOICE=YES",$status);
  &DRAMA::obey($SCUCD,"CONTINUE",$arg,{-deletearg=>0});
}

# Also stops the q
sub gui_refuse {
  my $arg = Arg->Create;
  my $status = new DRAMA::Status;
  $arg->PutString("Argument1","CHOICE=NO",$status);
  &DRAMA::obey($SCUCD,"CONTINUE",$arg,{-deletearg=>0});
  stopq;
}

sub gui_extend {
  # First need to put up an entry widget in a window
  # dialog box
  my $dialog = $MW->DialogBox(-title => "Extend Observation",
			      -buttons => ["Accept","Cancel"],
			     );

  # add on a entry widget
  my $ent = $dialog->add( 'LabEntry', 
			  -label => "Enter new number",
			  -width => 10 )->pack;

  # display it
  my $but = $dialog->Show;

  if ($but eq 'Accept') {
    my $n_extend = $ent->get;
    return unless $n_extend =~ /^\d+$/;

    # then read that and do the following in the callback
    my $arg = Arg->Create;
    my $status = new DRAMA::Status;
    $arg->PutString("Argument1","$n_extend",$status);
    &DRAMA::obey($SCUCD,"EXTEND",$arg,{-deletearg=>0});
  }

}


# This is the conversion routine for processing monitors
# from the NBS system

sub nbs_cvtsub {
  my ($param, $value) = @_;

  #print "PARAMETER: $param - $value\n";

  if ($param eq 'SCUCD_STAT') {
    # update value in monitor gui

    # it seems we sometimes get garbage at the end of the string
    # so chop it down to 79 characters before we start
    $value = substr($value,0,79);

    # trim it
    $value =~ s/\s+$//;

    # check to see if we are paused
    if ($value =~ /paused/i) {
      # Must put up ACCEPT/REFUSE request
      # Remember that we can not send an obey from
      # a monitor callback
      $MW->after(1, \&handle_accept)
	unless defined $ACC_GUI; # this deals with the multiple triggers;

    } else {
      # do nothing unless we have an open widget. In which case
      # we should remove the widget
      if ($ACC_GUI) {
	$ACC_GUI->destroy;
	undef $ACC_GUI;
      }
    }

  }

  return $value;

}

# Code to actually process a ACCEPT/REFUSE
sub handle_accept {
  my $self = shift;
  $ACC_GUI = $MW->DialogBox( -title => "Accept/Refuse observation",
				-buttons => ["Accept","Refuse","Accept+Stopq"],
			      );
  play_sound('chime.wav');
  my $button = $ACC_GUI->Show;

  # do not know what happens if the widget is destroyed
  # before the Show completes
  return unless $button;

  if ($button eq 'Accept') {
    &gui_accept;
  } elsif ($button eq 'Refuse') {
    &gui_refuse;
  } elsif ($button eq 'Accept+Stopq') {
    stopq;
    &gui_accept;
  }

  # remove it
  undef $ACC_GUI;

}

# This handles the right mouse button click on the
# contents window
# Takes arguments of: widget, index number, Xpos, Ypos
# X and Y are usually calculated with 

sub ContentsMenu {
  my $w = shift;
  my $index = shift;
  my $X = shift;
  my $Y = shift;

  my $menu = $MW->Menu(-tearoff => 0,
		       -menuitems => [
				      [
				       "command" => "Modify observation $index",
				       -command => sub {# do nothing 
				       },
				       -state => 'disabled',
				      ],
				      "separator",
				      ["command" => "Clear target index $index",
				       -command => sub {
					 my $arg = Arg->Create;
					 my $status = new DRAMA::Status;
					 $arg->Puti("Argument1",$index,$status);
					 DRAMA::obey($QNAME,"CLEARTARG",
						     $arg,{-deletearg=>0});}
				      ],
				      ["command" => "Cut observation at index $index",
				       -command => sub {
					 my $arg = Arg->Create;
					 my $status = new DRAMA::Status;
					 $arg->Puti("Argument1",$index,$status);
					 DRAMA::obey($QNAME,"CUTQ",
						     $arg,{-deletearg=>0});
				       }],
				      ["command" => "Cut MSB containing index $index",
				       -command => sub {
					 my $arg = Arg->Create;
					 my $status = new DRAMA::Status;
					 $arg->Puti("Argument1",$index,$status);
					 DRAMA::obey($QNAME,"CUTMSB",
						     $arg,{-deletearg=>0});
				       }],
				     ],
		      );
#  $menu->Popup(-popover => "cursor");
  $menu->Post($X,$Y);
}

# This method "cleans" an array so that empty lines are removed
# from the end as well as trailing space. Used to convert SDS arrays
# to a usable perl array.
# Takes the array ref and modifies it in place.

sub clean_array {
  my $arr = shift;

  @$arr = grep {/\w/} @$arr;
  foreach (@$arr) {
    s/\s+$//;
  }

}


# Subroutine to play a sound on the speaker. Do not test
# return value since it should be non-fatal if it fails
sub play_sound {
  my $file = shift;
  $file = File::Spec->catfile($AUDIO_DIR, $file);
  system("/usr/bin/esdplay",$file);
  return;
}

# These routines relate to the handling of DRAMA monitors

# See if we have monitors setup, connecting if we do not
# Given that it takes a finite time for the monitor to attach
# and for the CANCELLED variable to be changed, we should ensure
# that we do not check the monitors more often than necessary
# If passed a Tk widget (MainWindow) this routine will automatically
# reschedule itself

#   check_monitors( $MW, $time);

# The second argument specifies the rescheduling time in seconds.
# defaulting to 60

sub check_monitors {
  my ($w, $time) = @_;

  # The queue monitor
  if ($QUEUE_CANCELLED) {
    &init_queue_monitor;
  }

  # NBS
  if ($NBS_CANCELLED) {
    &init_nbs_monitors;
  }

  # reschedule if required
  if ($w) {
    $time = 60 unless (defined $time && $time > 0); # seconds

    # convert to milliseconds
    my $ms =  1000 * $time;

    # Set up the after
    $w->after( $ms, [\&check_monitors,$w, $time] );
  }

}

# Set up a monitor connection to the queue

sub init_queue_monitor {

  $QUEUE_CANCELLED = 0;
  write_info_message( $MsgText, "Configuring Queue monitor");

  monitor($QNAME, "START", 
	  "STATUS", "Queue", "CURRENT", "INDEX", "FAILURE","MSBCOMPLETED",
	  "MESSAGES","TIMEONQUEUE",
	  { -monitorvar => \%MONITOR,
	    -sendcur    => 1,
	    -repmonloss => 1,
	    -complete   => sub { write_info_message($MsgText,
						    "Monitor complete\n");
				 $QUEUE_CANCELLED=1 },
	    -info       => sub { print "Monitor INFO callback: $_[0]\n"},
	    -cvtsub     => \&cvtsub,
	    -error      => \&monerror,
	  });

}

# Set up a monitor to the NBS system
# Setup monitors of SCUBA parametera
sub init_nbs_monitors {
  $NBS_CANCELLED = 0;
  return unless $NBSTASK;
  my $status = new DRAMA::Status;
  my %params = ("SCUCD_STAT" => "APB.SCUBA_SCUCD_STAT",
		"INT_NUM" => "APB.SCUBA_INT_NUM"
	       );

  for my $par (keys %params) {
    my $arg = Arg->Create;
    $arg->PutString("SDP_PARAM",$par,$status);
    $arg->PutString("NBS_PARAM",$params{$par},$status);
    &DRAMA::obey($NBSTASK,"ADD",$arg,{-deletearg => 0});
  }

  # After a suitable amount of delay (10 seconds)
  # start the monitors
  $MW->after(10_000, sub { start_nbs_monitors(keys %params)});
}

#  my $arg2 = Arg->Create;
#  $arg2->PutString("SDP_PARAM","SCUCD_STAT",$status);
#  $arg2->PutString("NBS_PARAM","APB.SCUBA_SCUCD_STAT",$status);
#  &DRAMA::obeyw(NBSTASK,"ADD",$arg2);
#  sleep 1;

sub start_nbs_monitors {
  my @params = @_;
  return unless $NBSTASK;

  write_info_message( $MsgText, "Configuring NBS monitor");
  monitor($NBSTASK, "START", 
	  @params,
	{ -monitorvar => \%NBS_MONITOR,
	  -sendcur    => 1,
	  -repmonloss => 1,
	  -complete   => sub { write_info_message($MsgText,
						  "NBS Monitor complete\n");
			       $NBS_CANCELLED=1 },
	  -info       => sub { print "NBS Monitor INFO callback: $_[0]\n"},
	  -cvtsub     => \&nbs_cvtsub,
	  -error      => \&nbs_monerror,
	});

}


=head1 NOTES

Your OMP user ID will be requested on startup. This is in order
to allow you to specify a reason for accepting or rejecting the
MSB (if the need for a comment arises). If the user ID is not
supplied then no reason will be accepted.

=head1 SEE ALSO

L<Queue::Contents>, L<scuqueue>

=head1 AUTHOR

Tim Jenness, E<lt>t.jenness@jach.hawaii.eduE<gt>

Copyright (C) Particle Physics and Astronomy Research Council
1999-2002. All Rights Reserved.

=cut

