#!/usr/local/bin/perl

# Simple GUI to display queue status
use 5.006;
use strict;
use warnings;

use subs qw/update_status obeyw DoDramaEvents/;
use subs qw/cutq pasteq startq clearq stopq addback addfront/;
use vars qw/$VERSION/;

use Astro::SLA;

# Work out where local software is
use FindBin;
use lib "$FindBin::Bin/../site_perl";

# Start up Tk early and put up a status bar

my ($MW, $TKSTATUS, $BAR);

BEGIN {
  $VERSION = '0.11';
  use Tk;
  use Tk::ProgressBar;

  # Create a new main window
  $MW = MainWindow->new;
  $MW->title('JCMT OCS Queue monitor');
  $MW->iconname('JCMT_Q');

  $TKSTATUS = $MW->Label(qw(-width 40 -anchor w -foreground blue),
                       -text => "QMonitor $VERSION ...");
  $TKSTATUS->grid(-row => 0, -column => 0, -sticky => 'w'); 
  $BAR = $MW->ProgressBar(-from =>0, -to=>100, 
                            -width=>15, '-length'=>270,
                            -blocks => 20, -anchor => 'w',
                            -colors => [0, 'blue'],
                            -relief => 'sunken',
                            -borderwidth => 3,
                            -troughcolor => 'grey',
                           )->grid(-sticky => 's');
  $MW->update;
}

# The FAILURE response GUI
my $FAIL_GUI;

# File selection widget
require Tk::FileSelect;

update_status 'Loading DRAMA...',5;
eval "use DRAMA::Tk; use DRAMA";
if ($@) {
  die "Error loading DRAMA:\n$@";
}

update_status 'Loading Qcontrol class',50;
eval "use Queue::Control::DRAMA";
if ($@) {
  die "Error loading Queue::Control::DRAMA:\n$@";
}

update_status 'Loading ODF class',51;
eval "use SCUBA::ODF";
if ($@) {
  die "Error loading SCUBA::ODF:\n$@";
}

update_status 'Loading SrcCatalog class',52;
eval "use Tk::SrcCatalog";
if ($@) {
  die "Error loading Tk::SrcCatalog:\n$@";
}

#use Data::Dumper;

# Define the number of entries stored in QUEUE and PASTE parameters

# DEfine some constants - these are the same as used in the DQueue itseld
use constant NENTRIES => 10; # Number of entries in Queue parameters
use constant SZSTRING => 40; # Size of strings in Queue parameters
use constant QNAME    => 'SCUQUEUE'; # Name of Queue task
use constant TASKNAME => "QTK_$$"; # Name of this task

# Monitor variable
# %MONITOR contains the monitored variables
# $TOGGLE is used to determine the state of the START/STOPQ button
# $MORE_INFO is true if we are displaying the MsgOut text window
use vars qw/%MONITOR $TOGGLE $MORE_INFO/;

$TOGGLE = '---';

$| = 1;

# Initialise DRAMA system
update_status 'Initialise DRAMA',60;
DPerlTkInit(TASKNAME);


# Set the parameters for the Queue::Control::DRAMA class
# May want to import this parameter list from an external list

$Queue::Control::DRAMA::DEFAULTS = {
                OBSMODE => undef,
                CENTRE_OFFSET_X => 0,
                CENTRE_OFFSET_Y =>  0,
                CELL_X => 0,
                CELL_Y => 0,
                REFERENCE_X => 0,
                REFERENCE_Y => 0,
                CELL_COORDS => undef,
                SOURCE => undef,
                AZ_RANGE=> undef,
                CENTRE_TYPE => undef,
                CAROUSEL_TRACK=> undef,
                CATALOG => undef,
               };

$Queue::Control::DRAMA::QUEUE = QNAME;


############# G U I   C R E A T I O N ###############################

# Create three frames in top level
# Dont pack them until we are ready

my $Fr1 = $MW->Frame;
my $Fr2 = $MW->Frame;
my $Fr3 = $MW->Frame;
my $Fr4 = $MW->Frame;

# Make sure it is deleted correctly
$MW->protocol('WM_DELETE_WINDOW' => \&shutdown);

# Exit button
update_status 'Creating buttons',75;
$Fr3->Button( -text => 'EXIT', -command => \&shutdown)->pack(-side => 'left');
$Fr3->Button( -textvariable => \$TOGGLE,  -width => 10,-command => \&toggleq
		      )->pack(-side => 'left');
$Fr3->Button( -text => 'ADD', -command => \&launchFS)->pack(-side => 'left');
$Fr3->Button( -text => 'CLEAR',  -command => \&clearq)->pack(-side => 'left');
$Fr3->Button( -text => 'CUT',  -command => \&gui_cutq)->pack(-side => 'left');
$Fr3->Button( -text => 'PASTE',-command =>\&gui_pasteq)->pack(-side => 'left');

# Create a label for Queue status
$Fr1->Label(-text => 'Queue Status:')->grid(-row => 0,-col=>0,-sticky=>'w');
my $Qstatus = $Fr1->Label(-textvariable => \$MONITOR{STATUS},
			)->grid(-row=>0,-col=>1,-sticky=>'w');

$Fr1->Label(-text => 'Current entry:')->grid(-row => 1,-col=>0,-sticky=>'w');
my $CurrStatus = $Fr1->Label(-textvariable => \$MONITOR{CURRENT},
			)->grid(-row=>1,-col=>1,-sticky=>'w');

update_status 'Creating listboxes',85;
# Create listbox in frame 2
$Fr2->Label(-text => 'Queue contents')->grid(-row=>0,-col=>1);


#my $ContentsBox = $Fr2->ScrlListbox(-height => NENTRIES, 
#			     -width  => SZSTRING,
#			     -selectmode => 'single',
#			       )->grid(-row=>1,-col=>1);

my $ContentsBox = $Fr2->Scrolled('Text',
				 -scrollbars => 'e',
				 -wrap => 'none',
				 -height => NENTRIES, 
				 -width  => SZSTRING,
		#		 -state  => 'disabled',
			       )->grid(-row=>1,-col=>1);

$ContentsBox->bindtags(qw/widget_demo/);        # remove all bindings but dummy "widget_

# A numbered listbox
my $countBox = $Fr2->Listbox(-height => NENTRIES,
			     -width  => length(NENTRIES),
			     -relief => 'flat',
			    )->grid(-row=>1,-col=>0);

# Insert the numbers, padding with zeroes to right justify
$countBox->insert('end', 
		  map { ' 'x(length(NENTRIES)-length($_)).$_ } 1..NENTRIES);

# Make it look like we cant select anything
$countBox->configure(-selectbackground => $countBox->cget('-background'),
		     -selectforeground => $countBox->cget('-foreground'),
		    );

# Setup a Text widget that will take all the output sent to MsgOut

$MORE_INFO = 0;

my $MsgText = $Fr4->Scrolled('Text',-scrollbars=>'w',
			     -height=>8,
			     -width=>(2*SZSTRING)+2,
			    );

my $MsgBut = $Fr4->Checkbutton(-variable => \$MORE_INFO,
			       -text     => 'Info messages...',
			       -command => [\&show_info, $MsgText],
			      )->grid(-row=>0,-col=>1,-sticky=>'w');


# print information to this text widget
Dits::UfacePutMsgOut( sub { $MsgText->insert('end',"$_[0]\n");
			    $MsgText->see('end');
			  }, 
		      new DRAMA::Status);



# Set up a monitor - assumes that the QUEUE is running already
update_status 'Setting up monitor',95;

my $CANCELLED = 0;  # True if monitor is ended
monitor(QNAME, "START", 
	"STATUS", "Queue", "CURRENT", "INDEX", "FAILURE",
	{ -monitorvar => \%MONITOR,
	  -sendcur    => 1,
	  -repmonloss => 1,
	  -complete   => sub { $CANCELLED=1 },
	  -info       => sub { print "INFO callback\n"},
	  -cvtsub     => \&cvtsub,
	  -error      => \&monerror,
	});

# Destroy the progress bar
destroy $TKSTATUS if Exists($TKSTATUS);
destroy $BAR      if Exists($BAR);

# Finally, pack frames into top frame and enter main loop
$Fr1->grid(-row => 0, -col =>0, -sticky=>'w');
$Fr2->grid(-row => 1, -col =>0);
$Fr3->grid(-row => 2, -col =>0);
$Fr4->grid(-row => 3, -col =>0, -sticky=>'w');

#################### M A I N L O O P #####################################

# Start MainLoop;
MainLoop;

exit;


#################### S U B R O U T I N E S ###############################

# Subroutines go here


sub shutdown {

  # Need to release the monitor (unless that has been done already)
  if (exists $MONITOR{MONITOR_ID}) {
    monitor(QNAME, "CANCEL", $MONITOR{MONITOR_ID})
      unless $CANCELLED;
    select undef,undef,undef,0.1; # Wait for any shutdown messages
    DoDramaEvents;
  }
  # Need to clear the MsgOut tie
  Dits::UfacePutMsgOut( undef, new DRAMA::Status);

  # Destroy the window
  destroy $MW if Exists($MW);
}


# Convert subroutine - converts the parameter value
# to a value.
# For CURRENT and STATUS do nothing.
# For Queue convert to a hash and return
# Could do this in a trigger routine just as easily...

sub cvtsub {
  my ($param, $value) = @_;

  print "PARAMETER: $param\n";

  if ($param eq 'STATUS') {
    if ($value =~ /Stop/i) {
      $Qstatus->configure(-background=>'red',-foreground=>'black');
      $TOGGLE = 'STARTQ';
    } else {
      $Qstatus->configure(-background=>'green',-foreground=>'black');
      $TOGGLE = 'STOPQ';
    }
  } elsif ($param eq 'INDEX') {
    # Set the highlight position
    update_index( $value );
  }

  return $value if not ref($value);

  # Assume we have a Sds
  my %tie;
  tie %tie, "Sds::Tie", $value;

  if ($param eq 'Queue') {

    my %queue = %tie;

    # Strip trailing space and reduce array size
    foreach (@{$queue{'Contents'}}) {
      s/\s+$//;
    }


    # Update the Contents in the listbox
    &update_listboxes(\%queue);

    return \%queue;

  } elsif ($param eq 'FAILURE') {
    # When FAILURE triggers we should obtain the ODF, see what the problem
    # is, pop up a gui to request help.
    # Problem is that you can not do this until the monitor has completed.
    # If you try to do an obey to retrieve the ODF (if we decide not to publish
    # it as part of the FAILURE Sds parameter) you cannot use an "obeyw"
    # you can also not do any Tk event handling. The problem is the monitor
    # must complete before you go into any other event handling. This implies
    # that we have to set a variable from to indicate that FAILURE has returned
    # and then work that out when we enter the event loop. Easiest thing
    # is to do an after() for a few milliseconds later.

    use Data::Dumper;
    print Dumper(\%tie);

    # if we are prompting for changes to the ODF we
    # need to destroy that widget here because this may
    # indicate that someone else has responded or that another
    # problem is requested
    if ($FAIL_GUI) {
      $FAIL_GUI->destroy;
      undef $FAIL_GUI;
    }

    # first check that we have to react
    if (exists $tie{DETAILS}) {

      # Trigger a callback
      $MW->after(1, sub {respond_to_failure($tie{DETAILS})});

    }

  }

}


# Update the contents of the listbox. Usually called when monitor
# updates

sub update_listboxes {
  # Read the hash ref
  my $href = shift;

  # Clear the contents listbox
  $ContentsBox->configure( -state => 'normal');
  $ContentsBox->delete('0.0','end');
  # Fill it
  my $counter = 0;
  for my $line (@{$href->{Contents}}) {

    # Take local copy of index for callbacks
    my $index = $counter;

    # Generate the tag name based on the index
    my $dtag = "d" . $index;

    # Get the reference position
    my $start = $ContentsBox->index('insert');

    # insert the line
    $ContentsBox->insert('end', $line . "\n");

    # Remove all the tags at this position
    foreach my $tag ($ContentsBox->tag('names', $start)) {
        $ContentsBox->tag('remove', $tag, $start, 'insert');
    }

    # Create a new tag
    $ContentsBox->tag('add', $dtag, $start, 'insert');

    # bind the tag to button click
    $ContentsBox->tag('bind', $dtag, '<ButtonRelease-1>' =>
		      sub {pset(QNAME,"INDEX", $index)});

    $counter++;
  }

  $ContentsBox->configure( -state => 'disabled');
}

# Routine to update the position of the index.
# If no argument is supplied the value is obtained from the drama task
# via a pget
#   update_index( $index );

sub update_index {
  my $index = shift;

  my $tag = "d" . $index;

  # First need to configure all the existing tags so that they
  # are not
  foreach my $tag ($ContentsBox->tag('names')) {
    next unless $tag =~ /^d\d/;
    $ContentsBox->tag('configure', $tag, 
		      -foreground => 'black',
		      -background => 'white',
		     );
  }

    $ContentsBox->tag('configure', $tag, 
		      -foreground => 'white',
		      -background => 'black',
		     );

}


# Routine called during an error in the monitor

sub monerror {
  # Flush status
  $_[2]->Flush;
  $CANCELLED = 1;
}




# Start or stop the queue

sub toggleq {
  if ($MONITOR{STATUS} =~ /^Stop/i) {
#    print "Starting Q\n";
    startq;
  } else {
#    print "Stopping Q\n";
    stopq;
  }

}

# This subroutine updates the display widget on startup

sub update_status {
 
    my($status_text, $something) = @_;
 
    $TKSTATUS->configure(-text => "$status_text ...");
    $BAR->value($something);
    $MW->update;
 
}


# This routine withdraws or shows the MsgOut text widget
# depending on the value of $MORE_INFO.

sub show_info {
  my $w = shift;  # The text widget
  if ($MORE_INFO) {
    $w->grid(-row=>1,-col=>1,-sticky=>'e');
  } else {
    $w->gridForget;
  }
}


# Routine to launch a file selection widget that can be used
# to add ODFs to the queue

sub launchFS {
  $MW->FileSelect(-transient => 0,
		  -command => \&gui_addq,
		  -selectmode => 'extended',
		  -filelabel => 'Selected ODF File',
		  -filelistlabel => 'ODF files',
		 )->Show;
}


# Routine to actually take the output from the file selector
# and place it in the quueue.
# The location will be the back unless an entry in the queue
# is selected.
# This takes arguments of an array of file names including
# the full path

sub gui_addq {
  my @Odfs = @_;
  return unless scalar(@Odfs) > 0;

  # Read the selection from the listbox
  my @sel = $ContentsBox->curselection;

  print "Selection = @sel\n";

  if (@sel) {
    my $posn = $sel[0] + 1; # Start at 1

    print "PASTING at position $posn\n";

    # Paste to selected position
    pasteq $posn, @Odfs;

  } else {
    print "ADDBACK\n";
    # Paste at end of queue by default
    addback @Odfs;
  }

}


# GUI dealing with responding to a failure of an ODF to load
# because it is missing information
# Arguments are: The ODF, the failure details

sub respond_to_failure {
  my $details = shift;

  #print Dumper($details);

  if ($details->{REASON} eq 'MissingTarget') {
    # Let us try to get the ODF
    my $odf = new SCUBA::ODF( Hash => $details->{ENTRY});

    # First need to inform user of the request
    # (hopefully part of a single window)

    # Now create src catalog object
    # If we are a science observation (PHOTOM, MAP) then
    # the assumption is we are looking for a calibrator
    # (either secondary calibrator or planet)

    # if we are a POINTING or FOCUS then we need the pointing catalog
    my $cat = new SrcCatalog::JCMT( '/home/timj/jcmt/ocs/queue2/pointing.cat' );

    # in both cases we want to add the planets
    # for now just use pointing catalog

    # Now reduce list to those that are within 20 degrees of the
    # reference position

    # really want to sort by increasing distance from reference
    # and include the distance (in degrees) from the target.

    # there may be times (at the end of an MSB) when the previous
    # position should be included. That would require a change
    # to Queue::Backend::SCUCD

    # Create object based on AZEL
    # can only do distance if we know where we are now. May require
    # access to the TCS. If we do not have AZ just give everything
    if (exists $details->{AZ}) {
      my $refcoord = new Astro::Coords(az=> $details->{AZ},
				       el=> $details->{EL},
				       units=>'rad');

      # first 10 degrees
      my @results = $cat->findByArea( $refcoord,(10*60*60*Astro::SLA::DAS2R));

    }

    $FAIL_GUI = new Tk::SrcCatalog( $MW,-onDestroy => sub { $FAIL_GUI = undef;},
				    -upDate => sub {},
				    -addCmd => sub {
				      # First reset the gui object
				      undef $FAIL_GUI;

				      # The actual coordinate (come in as an array)
				      my $arr = shift;
				      my $c = $arr->[0];
				      print "C is $c\n";

				      # Store that coordinate in the
				      # object
				      $odf->setTarget( $c );
				      my %hash = $odf->odf;

				      # Add INDEX field
				      $hash{INDEX} = $details->{INDEX};

				      my $status = new DRAMA::Status;
				      my $sds = Sds->PutHash( \%hash, "ODF", $status);

				      # and load the ODF back in
				      &DRAMA::obey(QNAME, "REPLACEQ", $sds, { -deletearg => 0,
									      -success => sub {
										&DRAMA::obey(QNAME,"STARTQ");
									      },
									    } );

				    },
				    -catalog => $cat,
				    -transient => 1,
				  );

  } else {
    print "Unable to deal with reason: " . $details->{REASON}. "\n";
  }

}
