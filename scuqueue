#!/usr/local/bin/perl

=head1 SCUQUEUE

This is the DRAMA-based Queue. It is a layer on top of the 
Queue::* perl modules (Queue, Queue::Contents, Queue::Entry
and Queue::Backend). It is designed for use with the TODD.

The SCUBA system (SCUCD) itself must be running before the queue can
be started.  To start the queue simply run this program in the
background.  The Queue registers itself as B<SCUQUEUE> in the DRAMA
message system.

Queue clients (e.g. C<qmonitor> and C<qctrl>) can be started as required.

=head1 ACTIONS

The following DRAMA actions are supported:

=over 4

=item STARTQ

Start the queue so that items will be sent to the Todd.

=item STOPQ

Stop the queue. No new items will be sent to the Todd.

=item CLEARQ

Clear all items from the queue.

=item LOADQ

Clear the queue and add the specified ODF group file onto the queue.

Single argument: file name

[this is to get something done quickly. In the future may revert
to a system where the ODF is sent as an array of strings or something]

=item CUTQ

Cut entries from the queue. Two SDS arguments are supplied:

  INDEX - position/index in Queue to start cut (start at 0)
  NCUT - Number of entries to cut from the queue.

This may be reversed if followed by a PASTEQ before another
call to CUTQ.

=item POLL

This action continually checks the backend to see whether new
entries can be sent. This action reschedules itselfs on a regular 
basis and does not need to be started by an external obey.

=item SUSPENDMSB

Suspend the MSB at the current entry.

=item EXIT

Closedown the Queue.

=back

=head1 PARAMETERS

The following DRAMA parameters are available:

=over 4

=item Queue

This contains the information on the current contents of the
queue. This is an SDS structure stored in the
parameter containing a single array labelled "Contents".


=item STATUS

Whether the queue is running or not. (value is RUNNING or STOPPED).

=item INDEX

Current position in the queue.

=back

=head1 SEE ALSO

=head1 AUTHOR

Tim Jenness, E<lt>t.jenness@jach.hawaii.eduE<gt>

Copyright (C) Particle Physics and Astronomy Research Council
1999-2001. All Rights Reserved.

=cut

#use FindBin;
#use lib "$FindBin::Bin/../site_perl";

$| = 1;

use 5.006;
use strict;
use warnings;

use Data::Dumper;
use SCUBA::ODFGroup;

# Work out where local software is
use FindBin;
use lib "$FindBin::RealBin/lib";

# Need OMP class for done msb
use lib "/jac_sw/omp/msbserver";
use OMP::MSBServer;
use OMP::Info::Comment;
use OMP::Constants qw/ :done /;

# Load the DRAMA system
use DRAMA;
$DRAMA::MAXREPLIES = 20;

# Parameter system
use Sdp;

# Load the Queue system
use Queue::SCUCD;

# Declare global vars
use vars qw/$QUEUE $VERBOSE $LOCAL_INDEX $SIM %COMPLETE_DETAILS $TRANS_DIR/;

# Define the number of entries stored in QUEUE and PASTE parameters
use constant NENTRIES => 100;

# Define size of string representation used in QUEUE/PASTE parameters
use constant SZSTRING => 80;

# The task name
use constant TASKNAME => 'SCUQUEUE';

# Declare subs (actions)
use subs qw/ LOADQ STARTQ STOPQ CUTQ POLL EXIT GETODF
  update_contents_param update_status_param update_current_param
  /;

# Read command line options
use Getopt::Long;

my $status = GetOptions("verbose" => \$VERBOSE,
			"sim"     => \$SIM,
			"transdir=s"=> \$TRANS_DIR, # override translator dir
		       );


# Drama Good status
my $STATUS = new DRAMA::Status;

# Start the DRAMA system
DPerlInit(TASKNAME);

# Set up the actions
my $flag = 0;  # Not spawnable

Dits::DperlPutActions("STARTQ",  \&STARTQ,  undef,$flag,undef,$STATUS);
Dits::DperlPutActions("STOPQ",   \&STOPQ,   undef,$flag,undef,$STATUS);
Dits::DperlPutActions("LOADQ",  \&LOADQ,  undef,$flag,undef,$STATUS);
Dits::DperlPutActions("INSERTQ",  \&INSERTQ,  undef,$flag,undef,$STATUS);
Dits::DperlPutActions("CLEARQ", \&CLEARQ,    undef,$flag,undef,$STATUS);
Dits::DperlPutActions("POLL",    \&POLL,\&KICK_POLL,$flag,undef,$STATUS);
Dits::DperlPutActions("REPLACEQ", \&REPLACEQ,undef,$flag,undef,$STATUS);
Dits::DperlPutActions("EXIT",    \&EXIT,    undef,0,undef,$STATUS);
Dits::DperlPutActions("GETODF",    \&GETODF,    undef,0,undef,$STATUS);
Dits::DperlPutActions("CLEARTARG",    \&CLEARTARG,    undef,0,undef,$STATUS);
Dits::DperlPutActions("MSBCOMPLETE",  \&MSBCOMPLETE,    undef,0,undef,$STATUS);
Dits::DperlPutActions("CUTQ",  \&CUTQ,    undef,0,undef,$STATUS);
Dits::DperlPutActions("SUSPENDMSB",\&SUSPENDMSB, undef,0,undef,$STATUS);

# Set up a delay structure for rescheduling the POLL
my $RESCHED = Dits::DeltaTime(1,0);

# Create parameters
my $sdp = new Sdp;
$sdp->Create("STATUS","STRING",'Stopped');
$sdp->Create("INDEX","INT",0);
$LOCAL_INDEX = 0; # synchronize
$sdp->Create("CURRENT","STRING",'None');

my $queue_sds = Sds->Create("Queue",undef,Sds::STRUCT,0,$STATUS);
$queue_sds->Create("Contents",undef,Sds::CHAR,[SZSTRING,NENTRIES],$STATUS);

# This contains any information on ODFs that need more information
my $failure_sds = Sds->Create("FAILURE",undef, Sds::STRUCT,0,$STATUS);

# This contains queue completion triggers
my $msbcomplete_sds = Sds->Create("MSBCOMPLETED",undef, Sds::STRUCT,0,$STATUS);

# Create message parameter. Includes a status and a message
my $msg_sds = Sds->Create("MESSAGES",undef, Sds::STRUCT,0,$STATUS);
$msg_sds->Create("MESSAGE", undef, Sds::CHAR,[132,50],$STATUS);
$msg_sds->Create("STATUS",undef,Sds::INT,0,$STATUS);

# Initialise the arrays
{
  my @array = ();
  my $csds = $queue_sds->Find('Contents',$STATUS);
  $csds->PutStringArrayExists(\@array, $STATUS);
}

# Store them in the parameter system
$sdp->Create('','SDS',$queue_sds);
$sdp->Create('','SDS',$failure_sds);
$sdp->Create('','SDS',$msbcomplete_sds);
$sdp->Create('','SDS',$msg_sds);

addmessage(0, "Queue created at ".gmtime . "UT");

# Create a Queue
# This is a global, make sure that we only have one
# queue running
$QUEUE = new Queue::SCUCD;

# Set the task name
if ($SIM) {
  $QUEUE->backend->TASK( "SCUCD_PERL");
} else {
  $QUEUE->backend->TASK('SCUCD@SCUVAX');
}

# override translator directory
if ($TRANS_DIR) {
  print "Overriding translation directory: $TRANS_DIR\n";
  $Queue::Entry::SCUBAODF::TRANS_DIR = $TRANS_DIR;
}

# This is the callback when the MSB queue finishes
# all it needs to do is extract the MSBID and set the completion parameter
sub msbtidy {
  # KLUGE - assumes  SCUBAODF
  # would normally use a scuba sub class
  my $entry = shift;
  my $status = new DRAMA::Status;

  my %data;
  $data{REQUEST} = 1;

  # Get the MSBID
  my $odf = $entry->entity->odf;
  my $msbid = $odf->getMSBID;

  my $projectid = $odf->getProjectid;

  addmessage($status, "Queue contents fully observed");

  # if we do not have an MSBID and project then we cant do anything else
  # so dd not change the parameter
  if ($msbid && $projectid) {

    if ($projectid eq 'SCUBA' || $projectid =~ /JCMTCAL/ ) {
      addmessage($status, "Completed JCMT 'calibration' observations. No doneMSB");
      addmessage($status, "Project ID was $projectid");

    } elsif ($projectid eq 'UNKNOWN') {
      addmessage($status, "Unable to determine project ID. No doneMSB");

    } else {

      addmessage($status, "Possibility of marking MSB for project $projectid as done [MSB=$msbid]");

      # Store it
      $data{MSBID} = $msbid;
      $data{PROJECTID} = $projectid;

      %COMPLETE_DETAILS = %data;
      set_msbcomplete_parameter($status, %data);

    }

  } else {
    my $msg = "Queue contents fully observed but no MSBID or PROJECTID available.";
    addmessage($status, $msg)
  }
}

$QUEUE->backend->msbcomplete( \&msbtidy );


# Start the polling
obey TASKNAME,"POLL";

# Start the DRAMA event loop
Dits::MainLoop($STATUS);

# Shut down - note that the automatic shut down does not use
# the inherited status...
exit;

#################### A C T I O N S ##################################

# EXIT action
sub EXIT {
  my $status = shift;
  # pre-emptive tidy
  $QUEUE->contents->clearq;
  Dits::PutRequest(Dits::REQ_EXIT,$status);
  return $status;
}



sub ADDBACK {
  my $status = shift;

  DRAMA::MsgOut($status, "Running ADDBACK") if $VERBOSE;

  DRAMA::MsgOut($status, "ADDBACK NOT SUPPORTED");
  return;
  my $argId = Dits::GetArgument;

  # If no argument simply return
  return unless defined $argId;

  # Retrieve the ODF entries associated with the args
  my @entries = &Sds_to_Entry($argId);

  if ($#entries > -1) {
    # Add these entries to the back of the queue
    $QUEUE->contents->addback(@entries);

    # Update the DRAMA parameters
    update_contents_param($status);
    set_msbcomplete_parameter( $status, REQUEST => 0, MSBID => '',PROJECTID=>'' );
  }
  return $status;
}

sub LOADQ {
  my $status = shift;

  DRAMA::MsgOut( $status, "Running LOADQ" ) if $VERBOSE;

  my $argId = Dits::GetArgument;

  # If no argument simply return
  return unless defined $argId;

  # tie the argId to a perl Hash
  my %sds;
  tie %sds, 'Sds::Tie', $argId;

  my $grp = new SCUBA::ODFGroup( File => $sds{Argument1});
  my @entries = map { new Queue::Entry::SCUBAODF("X", $_) } $grp->odfs;

  # configure the entries
  $entries[0]->firstObs(1);
  $entries[-1]->lastObs(1);
  for (@entries) {
    $_->isMSB(1);
  }

  $QUEUE->contents->loadq( @entries );

  # Always clear if we have tweaked something
  clear_failure_parameter($status);
  set_msbcomplete_parameter( $status, REQUEST => 0, MSBID => '',PROJECTID=>'' );

#  print Dumper($grp);
#  print Dumper(\@entries);
#  print Dumper($QUEUE);
#  print "Found " . scalar(@entries) . " ODFs\n";

  return $status;
}


# Insert ODFs at the current (or specified) index
# Argument1: ODF file name
# Argument2 [optional] Index

sub INSERTQ {
  my $status = shift;

  DRAMA::MsgOut( $status, "Running INSERTQ" ) if $VERBOSE;

  my $argId = Dits::GetArgument;

  # If no argument simply return
  return unless defined $argId;

  # tie the argId to a perl Hash
  my %sds;
  tie %sds, 'Sds::Tie', $argId;

  # Needs to be a separate function
  my $grp = new SCUBA::ODFGroup( File => $sds{Argument1});
  my @entries = map { new Queue::Entry::SCUBAODF("X", $_) } $grp->odfs;

  # these entries are assumed to be calibrations

  # Get the index. Can come from the SDS
  my $newindex;
  if (exists $sds{Argument2}) {
    $newindex = $sds{Argument2};
  } else {
    # get the current index
    my $cur = $QUEUE->contents->curindex;
    if (defined $cur) {
      $newindex = $cur + 1;
    } else {
      $newindex = 0;
    }
  }

  $QUEUE->contents->insertq($newindex, @entries );

  # Always clear if we have tweaked something
  clear_failure_parameter($status);
  set_msbcomplete_parameter( $status, REQUEST => 0, MSBID => '',PROJECTID=>'' );

#  print Dumper($grp);
#  print Dumper(\@entries);
#  print Dumper($QUEUE);
#  print "Found " . scalar(@entries) . " ODFs\n";

  return $status;
}

# Replace an entry on the queue
# Argument is either SDS structure called ODF with a key INDEX
# or Argument1 == INDEX and Argument2 == ODF filename
# (latter can be used for ditscmd)
# Third argument controls whether the source parameters in this
# ODF are propogated to later ODFs that are missing targets.
# default is false. Parameter name is either Argument3 or 
# PROPSRC in the ODF SDS structure

# The status of the entry matches that of the one it replaces
# ie whether it is the first or last obs in an MSB

sub REPLACEQ {
  my $status = shift;

  DRAMA::MsgOut( $status, "Running REPLACEQ" ) if $VERBOSE;

  my $argId = Dits::GetArgument;

  # If no argument simply return
  return unless defined $argId;

  # tie the argId to a perl Hash
  $argId->List($status);
  my %sds;
  tie %sds, 'Sds::Tie', $argId;

  print Dumper(\%sds);

  my ($index, $odf, $propsrc);
  if (exists $sds{INDEX}) {
    $index = $sds{INDEX};
    $propsrc = $sds{PROPSRC};
    my %copy = %sds;
    delete $copy{INDEX};
    delete $copy{PROPSRC};
    $odf = new SCUBA::ODF(Hash => \%copy );
    print "Reading via ODF hash\n";

  } elsif (exists $sds{Argument1}) {
    $index = $sds{Argument1};
    my $odffile = $sds{Argument2};
    $odf = new SCUBA::ODF( File => $odffile );
    $propsrc = $sds{Argument3};
  }

  # Get the old entry
  my $old = $QUEUE->contents->getentry($index);

  # should set bad status on error
  my $entry = new Queue::Entry::SCUBAODF("X", $odf);
  $QUEUE->contents->replaceq( $index, $entry );

  # configure it
  $entry->isMSB( $old->isMSB );
  $entry->lastObs( $old->lastObs );
  $entry->firstObs( $old->firstObs );

  # if we are propogating source information we need to do it now
  $QUEUE->contents->propsrc($index, $odf->getTarget)
    if $propsrc;

  # Always clear if we have tweaked something
  clear_failure_parameter($status);

  return $status;
}

# Clear the target information associated with the specified
# index.
# Argument1 contains the index entry.

sub CLEARTARG {
  my $status = shift;

  DRAMA::MsgOut( $status, "Clearing target information" ) if $VERBOSE;

  my $argId = Dits::GetArgument;

  # If no argument simply return
  return unless defined $argId;

  # tie the argId to a perl Hash
  $argId->List($status);
  my %sds;
  tie %sds, 'Sds::Tie', $argId;

  my $index = $sds{Argument1};

  $QUEUE->contents->clear_target( $index );

  # update contents string
  update_contents_param($status);

  return $status;
}


sub ADDFRONT {
  my $status = shift;

  DRAMA::MsgOut($status, "Running ADDFRONT") if $VERBOSE;

  my $argId = Dits::GetArgument;

  # If no argument simply return
  return unless defined $argId;

  # Retrieve the ODF entries associated with the args
  my @entries = &Sds_to_Entry($argId);

  if ($#entries > -1) {
    # Add these entries to the back of the queue
    $QUEUE->contents->addfront(@entries);

    # Update the DRAMA parameters
    update_contents_param($status);
    set_msbcomplete_parameter( $status, REQUEST => 0, MSBID => '',PROJECTID=>'' );
  }
  return $status;
}

sub STARTQ {
  unless ($QUEUE->backend->qrunning) {
    $QUEUE->startq;
    DRAMA::MsgOut($_[0], "Queue is running");
  }
  # still sync parameters even if we do not print the message
  update_status_param($_[0]);
  clear_failure_parameter($_[0]);
}

sub STOPQ {
  if ($QUEUE->backend->qrunning) {
    $QUEUE->stopq;
    DRAMA::MsgOut($_[0], "Queue is stopped");
  }
  # still sync the parameter
  update_status_param($_[0]);
}

sub CLEARQ {
  $QUEUE->contents->clearq;
  DRAMA::MsgOut($_[0], "Queue cleared");
  update_contents_param($_[0]);
  update_index_param($_[0]);
  set_msbcomplete_parameter( $_[0], REQUEST => 0, MSBID => '',PROJECTID=>'' );
}

# Remove the entry at INDEX 
# Multiple entries can be cut at once using the second
# optional argument.

sub CUTQ {
  my $status = shift;

  DRAMA::MsgOut($status, "Running CUTQ") if $VERBOSE;

  my $argId = Dits::GetArgument;

  # If no argument simply return
  return unless defined $argId;

  # Retrieve the INDEX and NCUT integers from the Args
  my %sds;
  tie %sds, 'Sds::Tie', $argId;

  print Dumper(\%sds);

  my ($index, $ncut);
  if (exists $sds{INDEX}) {
    $index = $sds{INDEX};
    $ncut = $sds{NCUT};
  } elsif (exists $sds{Argument1}) {
    $index = $sds{Argument1};
    $ncut = $sds{Argument2};
  } else {
    DRAMA::MsgOut($status,"Unable to determine cut position");
    return;
  }
  $ncut = 1 unless defined $ncut;

  DRAMA::MsgOut($status,"Removing observation from index $index");

  # CUT
  $QUEUE->contents->cutq($index, $ncut);

  # Update the DRAMA parameters
  update_contents_param($status);

  return $status;
}

# SUSPENDMSB
# Suspend the MSB at the currently highlighted position
sub SUSPENDMSB {
  my $status = shift;

  # first get the current entry
  my $entry = $QUEUE->contents->curentry;
  unless ($entry) {
    DRAMA::MsgOut($status, "Suspend MSB attempted but no entries in queue");
    return $status;
  }

  # then ask the entry for the MSBID, ProjectID and ObsLabel
  # these should be methods of the entry but for now
  # we assume the "entity" has them
  my $proj = $entry->entity->getProjectid;
  my $msbid = $entry->entity->getMSBID;
  my $label = $entry->entity->getObsLabel;

  if ($proj && $msbid && $label) {
    OMP::MSBServer->suspendMSB($proj, $msbid, $label);

    DRAMA::MsgOut($status, "MSB for project $proj has been suspended at the current observation");

  } else {
    DRAMA::MsgOut($status, "Attempted to suspend MSB but was unable to determine either the label, projectid or MSBID from the current entry");
  }

  return $status;
}


# continuously rescheduling action
sub POLL {
  my $status = shift;

  DRAMA::MsgOut($status,"Polling backend")
    if $VERBOSE;

  # First make sure that the index parameter has not been changed
  # from under us. If it has we need to synch up and possibly
  # stop the queue. Only want to do this if the parameter
  # was changed not if the internal index has changed.
  check_index_param_sync( $status );

  # Poll the queue
  my ($pstat, $scuba_status, $message) = $QUEUE->backend->poll;

  # If pstat is false, set status to bad
  # If scuba status is bad also set status to bad.
  # Stop the queue in both cases, report the errors but then
  # carry on using good status
  if (!$pstat) {
    my $lstat = new DRAMA::Status;
    $lstat->SetStatus(Dits::APP_ERROR);
    $lstat->ErsRep(0,"Error polling the backend [$pstat] - Queue stopped");
    $lstat->Flush;

    # Did we get a reason
    my $r = $QUEUE->backend->failure_reason;
    if ($r) {
      # Did get a reason. Does it help?
      # Need to convert the details to a SDS object
      my %details = $r->details;
      $details{INDEX} = $r->index;
      $details{REASON} = $r->type;

      use Data::Dumper;
      print "detected a failure: " . Dumper(\%details) ."\n";

      set_failure_parameter( $lstat, %details );

      # dealt with it so clear the reason
      $QUEUE->backend->failure_reason(undef);
    }

    # error so we must stop the queue
    &STOPQ($lstat);

  } elsif (defined $scuba_status && $scuba_status != 0) {
    my $lstat = new DRAMA::Status;
    $lstat->SetStatus(Dits::APP_ERROR);
    $lstat->ErsRep(0,"Error from SCUBA: $message");
    $lstat->ErsRep(0,"Error from SCUBA: Stopping the queue");
    $lstat->Flush;
    &addmessage($scuba_status, $message);
    &addmessage($scuba_status, "Stopping the queue");
    &STOPQ($lstat);
  } elsif ($message) {
    &addmessage($scuba_status, $message);
  }

  # Update the DRAMA parameters
  update_contents_param($status);
  update_index_param($status);
  update_status_param($status);

  # Need to reschedule $RESCHED seconds
  Dits::PutDelay($RESCHED, $status);
  Dits::PutRequest(Dits::REQ_WAIT, $status);

#  print Dumper($status) . "\nSTATUS: ".$status->GetStatus . "\n";

  return $status;
}

# This routine kicks the POLLing and forces it to stop rescheduling
# itself

sub KICK_POLL {
  my $status = shift;
  DRAMA::MsgOut($status, "Kicked poll - ending");
  Dits::PutRequest(Dits::REQ_END, $status);
  return $status;
}

# retrieve an ODF
# ODF contents are put in an Sds structure using key
# ODF
# Index number is present in arg Argument1
sub GETODF {
  my $status = shift;
  my $arg = Dits::GetArgument( $status );
  my $index = $arg->Geti( "Argument1", $status );
  print "Request for index $index\n";

  my $entry = $QUEUE->contents->getentry($index);

  if ($entry) {
    my %odf = $entry->entity->odf;

    # Add entries as strings
    my $sds = Sds->PutHash( \%odf, "ODF", $status);
    print Dumper($sds);
    Dits::PutArgument($sds, Dits::ARG_COPY,$status);

  } else {
    # set status to bad
    die "Error retrieving ODF $index\n";
  }

}

# This action triggers MSBDONE
sub MSBCOMPLETE {
  my $status = shift;

  # argument is a boolean governing whether or not we should
  # mark the MSB as done or not
  my $arg = Dits::GetArgument( $status );
  my $mark = $arg->Geti( "Argument1", $status );

  # can do nothing if we do not have an MSBID or PROJECTID
  # Get the project details
  if (exists $COMPLETE_DETAILS{MSBID} && exists $COMPLETE_DETAILS{PROJECTID}) {
    if ($mark) {

      # Need to mark it as done
      OMP::MSBServer->doneMSB($COMPLETE_DETAILS{PROJECTID},
			      $COMPLETE_DETAILS{MSBID} );

      # and clear the hash
      %COMPLETE_DETAILS = ();

    } else {
      # file a comment to indicate that the MSB was rejected
      my $comment = new OMP::Info::Comment(status => OMP__DONE_REJECTED,
					   text => "This MSB was observed but was not accepted by the observer/TSS",
					  );

      OMP::MSBServer->addMSBcomment($COMPLETE_DETAILS{PROJECTID},
				    $COMPLETE_DETAILS{MSBID},
				    $comment);

      %COMPLETE_DETAILS = ();

    }

  }

  # reset the parameters regardless
  set_msbcomplete_parameter( $status, REQUEST => 0, MSBID => '',PROJECTID=>'' );

}


#--------------------------------------------------------------
# Utility routines (not ACTIONS)

# This routine converts an Sds structure to 
# a set of Queue::Entry::HashODF objects

# An ODF is assumed to either be a file name (assuming macro)
# or an actual ODF in key ODF in the supplied structure

# Looking for Arguments of form
#   ODFn => {
#            Label => 'label',
#            ODF   => { Actual key/values hash   }
#           }
# where n can be 0..$ncomp
# The entries will be placed on the queue in the numbered order

sub Sds_to_Entry {
  my $argId = shift;

  return unless defined $argId;

  # Need to check that we have a structure
  $argId->List(new DRAMA::Status);

  # tie the argId to a perl Hash
  my %sds;
  tie %sds, 'Sds::Tie', $argId;

  # Sort keys into ODFn order (also extract ODF entries)
  my @sorted = sort { substr($a,3) <=> substr($b,3) } grep {/^ODF\d/i} keys %sds;

  # Loop over keys searching for ODF\d entries
  my @entries;
  foreach my $key (@sorted) {
    # already know they match ODF\d from sort
    if ($key =~ /^ODF\d/i) {
      my $odf_entry = $sds{$key};
      my $label = $odf_entry->{Label};
      my %odf = %{$odf_entry->{ODF}};
      my $entry = $QUEUE->entryClass->new($label, \%odf);
      push(@entries, $entry) if defined $entry;
    }
  }

  untie $argId;
  return @entries;
}


# PARAMETER MANIPULATION

# Update the CONTENTS parameter
# Argument: inherited status

sub update_contents_param {
  return unless $_[0]->Ok;

  # Read the QUEUE parameter
  my $sds = $sdp->GetSds('Queue',$_[0]);
  return undef unless defined $sds;

  #$sds->List($_[0]);

  # Read the current queue contents
  # Note that the current contents will return an array containing
  # however many entries there are rather than the number of Queue
  # entries we have reserved
  my @Cur_contents = $QUEUE->contents->stringified;

  # Compare the current contents with the sds structure
  my $upd_con = compare_sds_to_perl($sds, 'Contents', \@Cur_contents, $_[0]);

  # If either of the update flags are true we should update
  my $update = 0;
  $update = 1 if $upd_con;

  # Notify the parameter system
  $sdp->Update($sds,$_[0]) if $update;

  # Clear any failure reasons if we have changed the Entries
  clear_failure_parameter($_[0]) if $update;

  # Check for the current value on the queue
  update_current_param($_[0]);

}

# Update the Stopped/Running flag using the STATUS parameter
# Argument: inherited status

sub update_status_param {
  my $status = shift;
  return unless $status->Ok;

  # Read the status parameter
  my $state = $sdp->GetString('STATUS',$status);

  # Read whether the Queue is running
  my $running = $QUEUE->backend->qrunning;

  # Only change the parameter if needed
  if ($state eq 'Running' && !$running) {
    $sdp->PutString('STATUS','Stopped',$status);
  } elsif ($state eq 'Stopped' && $running) {
    $sdp->PutString('STATUS','Running',$status);
  }

}

# Sync the index parameter with the queue
# Argument: inherited status

sub update_index_param {
  my $status = shift;
  return unless $status->Ok;

  # Read the status parameter
  my $index = $sdp->Geti('INDEX',$status);

  # Get the queue value
  my $curindex = $QUEUE->contents->curindex;

  # Currently the parameter defaults to 0 if there are no entries
  $curindex = 0 unless defined $curindex;

  # Only change the parameter if needed
  if ($index != $curindex) {
    #print "::--+-+-+-+ SYNC index [$index/$curindex]\n";
    $sdp->Puti('INDEX', $curindex, $status);

    # Remember to change the local perl version. This lets
    # us know when the parameter was changed by external command
    $LOCAL_INDEX = $curindex;

  }

}


# See if the queue index and parameter have changed independently
# The LOCAL_INDEX variable helps us with this since we know it
# can not be changed by an external prompt.
# Argument: inherited status

sub check_index_param_sync {
  my $status = shift;
  return unless $status->Ok;

  # Read the status parameter
  my $index = $sdp->Geti('INDEX',$status);

  # Get the queue value
  my $curindex = $QUEUE->contents->curindex;

  # Currently undef is not supported as a parameter value
  # so we change it to 0
  $curindex = 0 unless defined $curindex;

  # This means we should change the queue value if they are different
  # and if the parameter is not equal to the local cache
  # it is possible for the current index to be different to the 
  # parameter since the queue is updated asynchronously
  if ($index != $curindex && $index != $LOCAL_INDEX) {
    #print "+_+_+_+_+ Stopping queue due to index change [$index/$curindex]\n";
    $LOCAL_INDEX = $index;
    $QUEUE->contents->curindex( $index );
    &STOPQ($status);
    # Always clear if we have tweaked something
    clear_failure_parameter($status);
  }

}

# Update the Current string
# Argument: inherited status

sub update_current_param {
  return unless $_[0]->Ok;

  # Read the CURRENT parameter
  my $curr = $sdp->GetString('CURRENT', $_[0]);

  # Read the last_sent to the backend
  my $last_sent = $QUEUE->backend->last_sent;

  # If nothing on set now to 'None'
  my $now;
  if (defined $last_sent) {
    $now = $last_sent->string;
  } else {
    $now = 'None';
  }

  # Compare
  if ($now ne $curr) {
    $sdp->PutString('CURRENT',$now,$_[0]);
  }

}

# Clear the contents of the failure parameter
# Arguments: inherited status
sub clear_failure_parameter {
  my $status = shift;
  return unless $status->Ok;

  # Read the FAILURE parameter
  my $sds = $sdp->GetSds('FAILURE',$status);
  return undef unless defined $sds;

  # Now need to look for the DETAILS object
  # (use a private status)
  my $lstat = new DRAMA::Status;

  # it seems we have to trigger the update after the Sds structure
  # has been freed
  my $updated;
  {
    my $detsds = $sds->Find("DETAILS", $lstat);

    if ($detsds) {
      # if we have a DETAILS object we need to
      # configure it so that it is deleted when it goes out of scope
      $detsds->flags(1,1,1);

      $updated = 1;
    }
  }

  # and update the parameter
  $sdp->Update($sds,$status) if $updated;

  return;
}

# Set the contents of the failure parameter
# Arguments: Inherited status, information hash
sub set_failure_parameter {
  my $status = shift;
  return unless $status->Ok;

  # Read the FAILURE parameter
  my $sds = $sdp->GetSds('FAILURE',$status);
  return undef unless defined $sds;

  # Read the arguments
  my %details = @_;

  # KLUGE - currently GetSds blesses the Sds into Arg class
  # This breaks PutHash since it *must* work on Sds objects
  # in order for the correct Create to be called. I think this
  # means that at the very leasy Sds.pm needs to use SUPER::Create
  # rather than just the Arg Create method. For now we rebless
  bless $sds, "Sds";

  # Add entries as strings
  $sds->PutHash( \%details, "DETAILS", $status);

  #$sds->List($status);

  # Notify the parameter system
  $sdp->Update($sds,$status);

  return;
}

# Set the contents of the msb complete parameter
# Arguments: Inherited status, information hash
sub set_msbcomplete_parameter {
  my $status = shift;
  return unless $status->Ok;

  # Read the FAILURE parameter
  my $sds = $sdp->GetSds('MSBCOMPLETED',$status);
  return undef unless defined $sds;

  # Now need to look for the DETAILS object
  # (use a private status)
  my $lstat = new DRAMA::Status;

  # Have to remove the old entries
  {
    my $detsds = $sds->Find("DETAILS", $lstat);

    if ($detsds) {
      # if we have a DETAILS object we need to
      # configure it so that it is deleted when it goes out of scope
      $detsds->flags(1,1,1);
    }
  }

  # Read the arguments
  my %details = @_;

  print Dumper(\%details);
  print ($status->Ok ? "status ok\n" : "status bad\n");

  # standard kluge
  bless $sds, "Sds";

  # put in the inormation
  $sds->PutHash( \%details, "DETAILS", $status);

  $sds->List($status);

  # Notify the parameter system
  $sdp->Update($sds,$status);

  print "Get to the end of qcompleted param setting\n";
  return;
}

# Sub to compare an SDS array with a perl array, updating
# the SDS array if necessary
# Arguments: Sds structure
#            Name of structure
#            Reference to comparison array
#            Status

# Returns true if they were different, otherwise returns false

sub compare_sds_to_perl ($$$$) {
  die 'Usage: compare_sds_to_perl($sds,$name,$arref,$status)'
    unless (scalar(@_) == 4 && ref($_[2]) eq 'ARRAY'
	    && UNIVERSAL::isa($_[0],'Sds'));

  return unless $_[3]->Ok;

  my $sds = shift;
  my $name = shift;
  my $arr = shift;

  # Read the named item from the Sds component
  my $csds = $sds->Find($name,$_[0]);
  my @sds_contents = $csds->GetStringArray($_[0]);

  # Process this array to remove trailing spaces (padding)
  # and shorten the array to match the size of the first
  # empty string - this will make the comparison more robust
  for my $i (0..$#sds_contents) {
    $sds_contents[$i] =~ s/\s+$//;
    if ($sds_contents[$i] eq '') {
      $#sds_contents = $i - 1;
      last;
    }
  }

  # This flag is used ro report a difference
  # Start by assuming no difference
  my $cur_diff = 0;

  # Since we have tidied the original array we can compare number of entries
  # directly
  # Making sure we remember that it is possible for the array to have
  # more than NENTRIES in it.
  if (scalar(@$arr) <= NENTRIES && scalar(@sds_contents) != scalar(@$arr)) {
    # Different number of elements
    $cur_diff = 1;
  } else {
    # Step through the current contents and compare with the
    # parameter contents
    for my $i (0..$#sds_contents) {
      # Need to retrieve the current value and trim
      # it if it is longer than the size of the SDS array
      # Take null character into account
      my $current = $arr->[$i];
      $current = substr($current,0,SZSTRING-1) if length($current) >= SZSTRING;

      # Also need to trim trailing space
      $current =~ s/\s+$//;
	
      # Now compare the sds and current entries
      if ($sds_contents[$i] ne $current) {
	$cur_diff = 1;
	last;
      }
    }
  }

  # Update the Contents array if they are different
  $csds->PutStringArrayExists($arr, $_[0]) if $cur_diff;

  # Return the cur_diff flag - true if we have updated
  return $cur_diff;
}


# Store messages in the parameter that is monitored
# takes status and text message
sub addmessage {
  my ($msgstatus, $msg) = @_;

  # trap for DRAMA status
  if (UNIVERSAL::can($msgstatus, "GetStatus")) {
    # extract the value of the status
    $msgstatus = $msgstatus->GetStatus;
  }

  my $status = new DRAMA::Status;
  my $sds = $sdp->GetSds('MESSAGES',$status);
  return undef unless defined $sds;

  # split messages on new lines
  my @lines = split(/\n/,$msg);

  # print them using MsgOut
  DRAMA::MsgOut($status, $msg);

  my $msgsds = $sds->Find('MESSAGE',$status);
  return unless defined $msgsds;
  my $stsds = $sds->Find('STATUS',$status);
  return unless defined $stsds;

  use PDL;
  $msgsds->PutStringArrayExists(\@lines,$status);
  $stsds->PutPdl(pdl([$msgstatus]));
  $sdp->Update($sds,$status);
}
