#!/usr/local/bin/perl

=head1 NAME

SCUQUEUE - DRAMA-based queue for controlling SCUBA observing

=head1 SYNOPSIS

  scuqueue &
  scuqueue -sim -transdir /tmp

=head1 DESCRIPTION

This is the DRAMA-based Queue used to simplify the sequencing of SCUBA
ODFs. It is a layer on top of the Queue::* perl modules (Queue,
Queue::Contents, Queue::Entry and Queue::Backend).

The SCUBA system (SCUCD) itself must be running before the queue can
be started.  To start the queue simply run this program in the
background.  The Queue registers itself as B<SCUQUEUE> in the DRAMA
message system.

Queue clients (e.g. C<qmonitor>) can be started as required.

=head1 OPTIONS

The following command-line options are supported:

=over 4

=item B<-sim>

Run the task in simulate mode. When running in this mode
no commands are sent to the OMP database (MSBs are not marked
as complete) and the task does not attempt to talk to the SCUCD
task on SCUVAX. The task will attempt to talk to the demo scucd
program on the same machine (see L<scucd>).

=item B<-transdir>

The directory in which translated ODFs will appear. It is also
the directory  used to write rewritten ODFs prior to sending
them to SCUBA. Default is to use C</observe/ompodf>.

=item B<-help>

Print a small help message.

=item B<-man>

Print the full manual page.

=back

=head1 PARAMETERS

The following DRAMA parameters are available:

=over 4

=item Queue

This contains the information on the current contents of the
queue. This is an SDS structure stored in the parameter containing a
single array labelled "Contents".


=item STATUS

A string indicating whether the queue is running or not. (value is
RUNNING or STOPPED).


=item INDEX

Current position in the queue [INTEGER].

=item CURRENT

As string describing the entry that is currently being observed.

=item TIMEONQUEUE

The time (in minutes) remaining on the queue. [INTEGER]

=item FAILURE

An SDS structure containing details on why the queue was stopped.
Usually used to trigger a target request. Usually contains a single
structure (named "DETAILS") containing the reason type and the entry
number that triggered this reason.

=item MSBCOMPLETED

A SDS structure containing details on MSBs that have been completed
by the queue but are awaiting confirmation of status from the
observer. (see the MSBCOMPLETED action).

=item MESSAGES

SDS structure indicating the messages that can be displayed on a GUI.
Contains a MESSAGE string and STATUS integer.

=back

=cut

# Send all STDOUT immediately
$| = 1;

use 5.006;
use strict;
use warnings;

BEGIN { $ENV{SYBASE} = "/local/progs/sybase" unless exists $ENV{SYBASE}; }

use Data::Dumper;
use SCUBA::ODFGroup;

# Work out where local software is
use FindBin;
use lib "$FindBin::RealBin/lib";

# Need OMP class for done msb
use lib "/jac_sw/omp/msbserver";
use OMP::MSBServer;
use OMP::Info::Comment;
use OMP::Constants qw/ :done /;

# Load the DRAMA system
use DRAMA;
$DRAMA::MAXREPLIES = 40;

# Parameter system
use Sdp;

# Load the Queue system
use Queue::SCUCD;
use Queue::MSB;
use Queue::Entry::SCUBAODF;

# Declare global vars
use vars qw/$QUEUE $VERBOSE $LOCAL_INDEX $SIM %COMPLETE_DETAILS $TRANS_DIR/;

# Define the number of entries stored in QUEUE and PASTE parameters
use constant NENTRIES => 200;

# Define size of string representation used in QUEUE contents
use constant SZSTRING => 110;

# The task name
use constant TASKNAME => 'SCUQUEUE';

# Declare subs (actions)
use subs qw/ LOADQ STARTQ STOPQ CUTQ POLL EXIT GETODF
  update_contents_param update_status_param update_current_param
  /;

# Read command line options
use Getopt::Long;
use Pod::Usage;

my ($man,$help);
my $status = GetOptions("verbose" => \$VERBOSE,
			"sim"     => \$SIM,
			"transdir=s"=> \$TRANS_DIR, # override translator dir
			"help"    => \$help,
			"man"     => \$man,
		       );

pod2usage(1)  if ($help);
pod2usage(-verbose => 2)  if ($man);



# Drama Good status
my $STATUS = new DRAMA::Status;

# Start the DRAMA system
DPerlInit(TASKNAME);

# Set up the actions
my $flag = 0;  # Not spawnable

Dits::DperlPutActions("STARTQ",     \&STARTQ,  undef,$flag,undef,$STATUS);
Dits::DperlPutActions("STOPQ",      \&STOPQ,   undef,$flag,undef,$STATUS);
Dits::DperlPutActions("LOADQ",      \&LOADQ,  undef,$flag,undef,$STATUS);
Dits::DperlPutActions("ADDBACK",    \&ADDBACK,  undef,$flag,undef,$STATUS);
Dits::DperlPutActions("ADDFRONT",   \&ADDFRONT,  undef,$flag,undef,$STATUS);
Dits::DperlPutActions("INSERTQ",    \&INSERTQ,  undef,$flag,undef,$STATUS);
Dits::DperlPutActions("CLEARQ",     \&CLEARQ,    undef,$flag,undef,$STATUS);
Dits::DperlPutActions("POLL",       \&POLL,\&KICK_POLL,$flag,undef,$STATUS);
Dits::DperlPutActions("REPLACEQ",   \&REPLACEQ,undef,$flag,undef,$STATUS);
Dits::DperlPutActions("EXIT",       \&EXIT,    undef,0,undef,$STATUS);
Dits::DperlPutActions("GETODF",     \&GETODF,    undef,0,undef,$STATUS);
Dits::DperlPutActions("CLEARTARG",  \&CLEARTARG,    undef,0,undef,$STATUS);
Dits::DperlPutActions("MSBCOMPLETE",\&MSBCOMPLETE,    undef,0,undef,$STATUS);
Dits::DperlPutActions("CUTQ",       \&CUTQ,    undef,0,undef,$STATUS);
Dits::DperlPutActions("CUTMSB",     \&CUTMSB,    undef,0,undef,$STATUS);
Dits::DperlPutActions("SUSPENDMSB", \&SUSPENDMSB, undef,0,undef,$STATUS);
Dits::DperlPutActions("DONEMSB",    \&DONEMSB, undef,0,undef,$STATUS);

# Set up a delay structure for rescheduling the POLL
my $RESCHED = Dits::DeltaTime(1,0);

# Create parameters
my $sdp = new Sdp;
$sdp->Create("STATUS","STRING",'Stopped');
$sdp->Create("INDEX","INT",0);
$sdp->Create("TIMEONQUEUE","INT",0);
$LOCAL_INDEX = 0; # synchronize
$sdp->Create("CURRENT","STRING",'None');

my $queue_sds = Sds->Create("Queue",undef,Sds::STRUCT,0,$STATUS);
$queue_sds->Create("Contents",undef,Sds::CHAR,[SZSTRING,NENTRIES],$STATUS);

# This contains any information on ODFs that need more information
my $failure_sds = Sds->Create("FAILURE",undef, Sds::STRUCT,0,$STATUS);

# This contains queue completion triggers
my $msbcomplete_sds = Sds->Create("MSBCOMPLETED",undef, Sds::STRUCT,0,$STATUS);

# Create message parameter. Includes a status and a message
my $msg_sds = Sds->Create("MESSAGES",undef, Sds::STRUCT,0,$STATUS);
$msg_sds->Create("MESSAGE", undef, Sds::CHAR,[132,50],$STATUS);
$msg_sds->Create("STATUS",undef,Sds::INT,0,$STATUS);

# Initialise the arrays
{
  my @array = ();
  my $csds = $queue_sds->Find('Contents',$STATUS);
  $csds->PutStringArrayExists(\@array, $STATUS);
}

# Store them in the parameter system
$sdp->Create('','SDS',$queue_sds);
$sdp->Create('','SDS',$failure_sds);
$sdp->Create('','SDS',$msbcomplete_sds);
$sdp->Create('','SDS',$msg_sds);

addmessage(0, "Queue created at ".gmtime . "UT");

# Create a Queue
# This is a global, make sure that we only have one
# queue running
$QUEUE = new Queue::SCUCD;

# Set the task name
if ($SIM) {
  $QUEUE->backend->TASK( "SCUCD_PERL");
} else {
  $QUEUE->backend->TASK('SCUCD@SCUVAX');
}

# override translator directory
if ($TRANS_DIR) {
  print "Overriding translation directory: $TRANS_DIR\n";
  $Queue::Entry::SCUBAODF::TRANS_DIR = $TRANS_DIR;
}

# Register this routine with the backend class
$QUEUE->backend->msbcomplete( \&msbtidy );


# Start the polling
obey TASKNAME,"POLL";

# Start the DRAMA event loop
Dits::MainLoop($STATUS);

# Shut down - note that the automatic shut down does not use
# the inherited status...
exit;

#################### A C T I O N S ##################################

=head1 ACTIONS

The following DRAMA actions are supported:

=over 4

=item B<EXIT>

Cause the task to shutdown and exit. No arguments.

=cut

# EXIT action
sub EXIT {
  my $status = shift;
  return $status unless $status->Ok;
  # pre-emptive tidy
  $QUEUE->contents->clearq;
  Dits::PutRequest(Dits::REQ_EXIT,$status);
  return $status;
}

=item B<STARTQ>

Start the queue.

=cut

sub STARTQ {
  return $_[0] unless $_[0]->Ok;
  unless ($QUEUE->backend->qrunning) {
    $QUEUE->startq;
    DRAMA::MsgOut($_[0], "Queue is running");
  }
  # still sync parameters even if we do not print the message
  update_status_param($_[0]);
  clear_failure_parameter($_[0]);
}

=item B<STOPQ>

Stop the queue from sending any more entries to the backend.

=cut

sub STOPQ {
  return $_[0] unless $_[0]->Ok;
  if ($QUEUE->backend->qrunning) {
    $QUEUE->stopq;
    DRAMA::MsgOut($_[0], "Queue is stopped");
  }
  # still sync the parameter
  update_status_param($_[0]);
}

=item B<CLEARQ>

Remove all entries from the queue.

=cut

sub CLEARQ {
  return $_[0] unless $_[0]->Ok;
  $QUEUE->contents->clearq;
  DRAMA::MsgOut($_[0], "Queue cleared");
  update_contents_param($_[0]);
  update_index_param($_[0]);
}


=item B<LOADQ>

Clear the queue and load the specified ODFs onto it.
Accepts a single argument that specifies the ODF file
name of the ODF macro name. See C<Sds_to_Entry>.

=cut

sub LOADQ {
  my $status = shift;
  return $status unless $status->Ok;

  DRAMA::MsgOut( $status, "Running LOADQ" ) if $VERBOSE;

  my $argId = Dits::GetArgument;

  # If no argument simply return
  return unless defined $argId;

  # Extract the ODF entries from the argument
  my @entries = &Sds_to_Entry( $argId );

  $QUEUE->contents->loadq( @entries );

  # Always clear if we have tweaked something
  clear_failure_parameter($status);


#  print Dumper($grp);
#  print Dumper(\@entries);
#  print Dumper($QUEUE);
#  print "Found " . scalar(@entries) . " ODFs\n";

  return $status;
}


=item B<ADDBACK>

Add the supplied ODFs to the back of the queue.
Accepts the same arguments as C<LOADQ>.

If the time remaining on the queue exceeds a threshold
the action will fail and return with bad status.

=cut

sub ADDBACK {
  my $status = shift;
  return $status unless $status->Ok;

  DRAMA::MsgOut($status, "Running ADDBACK") if $VERBOSE;

  # Verify time remaining on queue
  verify_time_remaining( $status );
  return $status unless $status->Ok;

  # Read the arguments
  my $argId = Dits::GetArgument;

  # If no argument simply return
  return $status unless defined $argId;

  # Retrieve the ODF entries associated with the args
  my @entries = &Sds_to_Entry($argId);

  if ($#entries > -1) {
    # Add these entries to the back of the queue
    $QUEUE->contents->addback(@entries);

    # Update the DRAMA parameters
    update_contents_param($status);

  }
  return $status;
}

=item B<ADDFRONT>

Add the supplied ODFs to the front of the queue.
Accepts the same arguments as C<LOADQ>.

If the time remaining on the queue exceeds a threshold
the action will fail and return with bad status.

=cut

sub ADDFRONT {
  my $status = shift;
  return $status unless $status->Ok;

  DRAMA::MsgOut($status, "Running ADDFRONT") if $VERBOSE;

  # Verify time remaining on queue
  verify_time_remaining( $status );
  return $status unless $status->Ok;

  # Read the arguments
  my $argId = Dits::GetArgument;

  # If no argument simply return
  return $status unless defined $argId;

  # Retrieve the ODF entries associated with the args
  my @entries = &Sds_to_Entry($argId);

  if ($#entries > -1) {
    # Add these entries to the back of the queue
    $QUEUE->contents->addfront(@entries);

    # Update the DRAMA parameters
    update_contents_param($status);

  }
  return $status;
}


=item B<INSERTQ>

Insert calibration ODFs into the queue at the current highlight
or at the specified index. Note that these calibrations are not
treated as MSBs.

ODFs are specified in the same way as for C<LOADQ>.

The optional index can be specified as "Argument2".

=cut

sub INSERTQ {
  my $status = shift;
  return $status unless $status->Ok;

  DRAMA::MsgOut( $status, "Running INSERTQ" ) if $VERBOSE;

  my $argId = Dits::GetArgument;

  # If no argument simply return
  return unless defined $argId;

  # Get the entries [mark them as calibrations]
  my @entries = &Sds_to_Entry( $argId, 1);

  # Tie the Sds to a hash to get at the second argument
  my %sds;
  tie %sds, 'Sds::Tie', $argId;

  # Get the index. Can come from the SDS
  my $newindex;
  if (exists $sds{Argument2}) {
    $newindex = $sds{Argument2};
  } else {
    # get the current index
    my $cur = $QUEUE->contents->curindex;
    if (defined $cur) {
      $newindex = $cur + 1;
    } else {
      $newindex = 0;
    }
  }

  $QUEUE->contents->insertq($newindex, @entries );

  # Always clear if we have tweaked something
  clear_failure_parameter($status);


#  print Dumper($grp);
#  print Dumper(\@entries);
#  print Dumper($QUEUE);
#  print "Found " . scalar(@entries) . " ODFs\n";

  return $status;
}

=item B<REPLACEQ>

Replace an entry on the queue with another. This action takes three
arguments. An index specifying the location in the queue to place the
new entry, the ODF specification itself (as a filename), and a logical
indicating whether source information from this ODF should be
propagated to following entries. The arguments can either be specified
by number ("Argument1" for the index and "Argument2" for the file name
and "Argument3" for the source propagation flag) or by name (INDEX and
PROPSRC, all remaining SDS entries used to construct a single ODF
directly).

The status of the entry matches that of the one it replaces
ie whether it is the first or last obs in an MSB. It is automatically
associated with the MSB of the entry it is replacing.

=cut

sub REPLACEQ {
  my $status = shift;
  return $status unless $status->Ok;

  DRAMA::MsgOut( $status, "Running REPLACEQ" ) if $VERBOSE;

  my $argId = Dits::GetArgument;

  # If no argument simply return
  return unless defined $argId;

  # tie the argId to a perl Hash
  $argId->List($status);
  my %sds;
  tie %sds, 'Sds::Tie', $argId;

  print Dumper(\%sds);

  my ($index, $odf, $propsrc);
  if (exists $sds{INDEX}) {
    $index = $sds{INDEX};
    $propsrc = $sds{PROPSRC};
    my %copy = %sds;
    delete $copy{INDEX};
    delete $copy{PROPSRC};
    $odf = new SCUBA::ODF(Hash => \%copy );
    print "Reading via ODF hash\n";

  } elsif (exists $sds{Argument1}) {
    $index = $sds{Argument1};
    my $odffile = $sds{Argument2};
    $odf = new SCUBA::ODF( File => $odffile );
    $propsrc = $sds{Argument3};
  }

  # Get the old entry
  my $old = $QUEUE->contents->getentry($index);

  # should set bad status on error
  # Create a new entry
  my $entry = new Queue::Entry::SCUBAODF("X", $odf);

  # Replace the old entry
  $QUEUE->contents->replaceq( $index, $entry );

  # if we are propogating source information we need to do it now
  $QUEUE->contents->propsrc($index, $odf->getTarget)
    if $propsrc;

  # Always clear if we have tweaked something
  clear_failure_parameter($status);

  return $status;
}

=item B<CLEARTARG>

Clear the target information associated with the specified index.
"Argument1" contains the index entry.

=cut

sub CLEARTARG {
  my $status = shift;
  return $status unless $status->Ok;

  DRAMA::MsgOut( $status, "Clearing target information" ) if $VERBOSE;

  my $argId = Dits::GetArgument;

  # If no argument simply return
  return unless defined $argId;

  # tie the argId to a perl Hash
  $argId->List($status);
  my %sds;
  tie %sds, 'Sds::Tie', $argId;

  my $index = $sds{Argument1};

  $QUEUE->contents->clear_target( $index );

  # update contents string
  update_contents_param($status);

  return $status;
}


=item B<CUTQ>

Remove entries beginning at the specified index position.  The index
is mandatory (either as "Argument1" or as "INDEX") and an optional
parameter can be used to specify the number of entries to remove
("Argument2" or "NCUT"). Defaults to a single entry.

=cut

sub CUTQ {
  my $status = shift;
  return $status unless $status->Ok;

  DRAMA::MsgOut($status, "Running CUTQ") if $VERBOSE;

  my $argId = Dits::GetArgument;

  # If no argument simply return
  return unless defined $argId;

  # Retrieve the INDEX and NCUT integers from the Args
  my %sds;
  tie %sds, 'Sds::Tie', $argId;

  print Dumper(\%sds);

  my ($index, $ncut);
  if (exists $sds{INDEX}) {
    $index = $sds{INDEX};
    $ncut = $sds{NCUT};
  } elsif (exists $sds{Argument1}) {
    $index = $sds{Argument1};
    $ncut = $sds{Argument2};
  } else {
    addmessage($status,"Unable to determine cut position");
    return;
  }
  $ncut = 1 unless defined $ncut;

  addmessage($status,"Removing $ncut observation[s] starting from index $index");

  # CUT
  $QUEUE->contents->cutq($index, $ncut);

  # Update the DRAMA parameters
  update_contents_param($status);

  return $status;
}

=item B<CUTMSB>

Remove the MSB associated with the currently highlighted observation
or the supplied index. The optional index can be specified as either
"Argument1" or as "INDEX" in the SDS argument structure.

=cut

sub CUTMSB {
  my $status = shift;
  return $status unless $status->Ok;

  DRAMA::MsgOut($status, "Running CUTMSB") if $VERBOSE;

  my $argId = Dits::GetArgument;

  # If no argument simply return
  return unless defined $argId;

  # Retrieve the INDEX integer from the Args
  my %sds;
  tie %sds, 'Sds::Tie', $argId;

  print Dumper(\%sds);

  my $index;
  if (exists $sds{INDEX}) {
    $index = $sds{INDEX};
  } elsif (exists $sds{Argument1}) {
    $index = $sds{Argument1};
  }


  # Make sure there are entries in the queue
  return $status unless defined $QUEUE->contents->countq;

  $QUEUE->contents->cutmsb($index);

  return $status;
}

=item B<SUSPENDMSB>

Suspend the MSB at the currently highlighted position.  The MSB is
removed from the queue. This method takes no arguments.

=cut

sub SUSPENDMSB {
  my $status = shift;
  return $status unless $status->Ok;

  # first get the current entry
  my $entry = $QUEUE->contents->curentry;
  unless ($entry) {
    addmessage($status, "Suspend MSB attempted but no entries in queue");
    return $status;
  }

  # then ask the entry for the MSBID, ProjectID and ObsLabel
  # these should be methods of the entry but for now
  # we assume the "entity" has them
  my $proj = $entry->projectid;
  my $msbid = $entry->msbid;
  my $label = $entry->entity->getObsLabel;

  if ($proj && $msbid && $label) {
    # Suspend the MSB unless we are in simulate mode
    OMP::MSBServer->suspendMSB($proj, $msbid, $label)
	unless $SIM;

    addmessage($status, "MSB for project $proj has been suspended at the current observation");

    # Now need to cut the MSB without triggering accept/reject
    my $msb = $entry->msb;
    if (defined $msb) {
      $msb->hasBeenObserved(0);
    }

    # and cut it
    $QUEUE->contents->cutmsb( $QUEUE->contents->curindex );

  } else {
    addmessage($status, "Attempted to suspend MSB but was unable to determine either the label, projectid or MSBID from the current entry");
  }

  return $status;
}

=item B<DONEMSB>

Mark the MSB as done [relies on the MSB entry being active] that is
associated with the currently highlighted position.

Not clear that this has any additional functionality over CUTMSB since
we do not want to mark it done if it has not been observed at all and
we would probably like to be asked about it.

This action should be used with caution since it will always mark the
MSB as complete if it can obtain the project ID and MSBID from the
entry, regardless of whether it has been observed. This action
needs to be reviewed.

=cut

sub DONEMSB {
  my $status = shift;
  return $status unless $status->Ok;

  # first get the current entry
  my $entry = $QUEUE->contents->curentry;
  unless ($entry) {
    addmessage($status, "Explicit 'done MSB' attempted but no entries in queue");
    return $status;
  }

  addmessage($status, "doneMSB currently not supported. Pending review");
  return $status;

  # then ask the entry for the MSBID and projectID
  # these should be methods of the entry but for now
  # we assume the "entity" has them
  my $proj = $entry->projectid;
  my $msbid = $entry->msbid;

  if ($proj && $msbid) {

    if ($proj =~ /SCUBA|JCMTCAL/) {
      addmessage($status, "Can not mark a standard calibration as complete");
    } else {
      # Only mark as done if we are in live mode
      OMP::MSBServer->doneMSB($proj, $msbid)
	  unless $SIM;

      addmessage($status, "MSB for project $proj has been marked as completed");
    }

  } else {
    addmessage($status, "Attempted to mark an MSB as complete but was unable to determine either the projectid or MSBID from the current entry");
  }

  return $status;
}

=item B<POLL>

This is the core action in the queue. It continually reschedules
itself checking to make sure that the queue is in a good state and
sending the next entry if the queue is active and the backend is ready
to accept it. This action is triggered by the queue on startup. It can
be kicked to disable the rescheduling.

=cut

# continuously rescheduling action
sub POLL {
  my $status = shift;
  return $status unless $status->Ok;

  DRAMA::MsgOut($status,"Polling backend")
    if $VERBOSE;

  # First make sure that the index parameter has not been changed
  # from under us. If it has we need to synch up and possibly
  # stop the queue. Only want to do this if the parameter
  # was changed not if the internal index has changed.
  check_index_param_sync( $status );

  # Poll the queue
  my ($pstat, $scuba_status, $message) = $QUEUE->backend->poll;

  # If pstat is false, set status to bad
  # If scuba status is bad also set status to bad.
  # Stop the queue in both cases, report the errors but then
  # carry on using good status
  if (!$pstat) {
    my $lstat = new DRAMA::Status;
    $lstat->SetStatus(Dits::APP_ERROR);
    $lstat->ErsRep(0,"Error polling the backend [$pstat] - Queue stopped");
    $lstat->Flush;

    # Did we get a reason
    my $r = $QUEUE->backend->failure_reason;
    if ($r) {
      # Did get a reason. Does it help?
      # Need to convert the details to a SDS object
      my %details = $r->details;
      $details{INDEX} = $r->index;
      $details{REASON} = $r->type;

      use Data::Dumper;
      print "detected a failure: " . Dumper(\%details) ."\n";

      set_failure_parameter( $lstat, %details );

      # dealt with it so clear the reason
      $QUEUE->backend->failure_reason(undef);
    }

    # error so we must stop the queue
    &STOPQ($lstat);

  } elsif (defined $scuba_status && $scuba_status != 0) {
    my $lstat = new DRAMA::Status;
    $lstat->SetStatus(Dits::APP_ERROR);
    $lstat->ErsRep(0,"Error from SCUBA: $message");
    $lstat->ErsRep(0,"Error from SCUBA: Stopping the queue");
    $lstat->Flush;
    &addmessage($scuba_status, $message);
    &addmessage($scuba_status, "Stopping the queue");
    &STOPQ($lstat);
  } elsif ($message) {
    &addmessage($scuba_status, $message);
  }

  # Update the DRAMA parameters
  update_contents_param($status);
  update_index_param($status);
  update_status_param($status);

  # Need to reschedule $RESCHED seconds
  Dits::PutDelay($RESCHED, $status);
  Dits::PutRequest(Dits::REQ_WAIT, $status);

#  print Dumper($status) . "\nSTATUS: ".$status->GetStatus . "\n";

  return $status;
}

# This routine kicks the POLLing and forces it to stop rescheduling
# itself

sub KICK_POLL {
  my $status = shift;
  return $status unless $status->Ok;
  DRAMA::MsgOut($status, "Kicked poll - ending");
  Dits::PutRequest(Dits::REQ_END, $status);
  return $status;
}


=item B<GETODF>

Retrieves the contents of an ODF from the queue using the specified
index position. The index is specified as "Argument1".

The Sds structure returned by this action has a key "ODF"
containing the keyword/value pairs that form the ODF itself.

Usually used to force a new target into an ODF in conjunction
with REPLACEQ.

Note that there is no C<SETTARG> action.

=cut

sub GETODF {
  my $status = shift;
  return $status unless $status->Ok;

  my $arg = Dits::GetArgument( $status );
  my $index = $arg->Geti( "Argument1", $status );
  print "Request for index $index\n";

  my $entry = $QUEUE->contents->getentry($index);

  if ($entry) {
    my %odf = $entry->entity->odf;

    # Add entries as strings
    my $sds = Sds->PutHash( \%odf, "ODF", $status);
    print Dumper($sds);
    Dits::PutArgument($sds, Dits::ARG_COPY,$status);

  } else {
    # set status to bad
    die "Error retrieving ODF $index\n";
  }

}

=item B<MSBCOMPLETE>

This action sends a doneMSB or rejectMSB to the OMP database
if the corresponding entries can be found in the completion
data structure.

Sds Argument contains a structure with a timestamp key (which must be
recognized by the system [ie in the completion parameter]) pointing
to:

  COMPLETE   - logical (doneMSB or rejectMSB)
  USERID     - user associated with this request [optional]
  REASON     - String describing any particular reason

There can be more than one timestamp entry so we can trigger
multiple MSBs at once (this will be the case if we have been
running the queue without a monitor GUI).

Alternatively, for ease of use at the command line we also support
Argument1=timestamp Argument2=complete Argument3=userid
Argument4=reason

=cut

sub MSBCOMPLETE {
  my $status = shift;
  return $status unless $status->Ok;

  DRAMA::MsgOut($status,"MSB COMPLETE")
    if $VERBOSE;

  # argument is a boolean governing whether or not we should
  # mark the MSB as done or not
  my $arg = Dits::GetArgument( $status );

  # Tie to a hash
  my %sds;
  tie %sds, 'Sds::Tie', $arg;

  use Data::Dumper;
  print Dumper( \%sds );

  my @completed;
  if (exists $sds{Argument1}) {
    # We have numbered args
    push(@completed, { timestamp => $sds{Argument1},
		       complete => $sds{Argument2},
		       userid => $sds{Argument3},
		       reason => $sds{Argument4},
		     });
  } else {
    # We have timestamp args
    for my $key (keys %sds) {
      # see if we have a hash ref
      next unless ref($sds{$key}) eq 'HASH';
      push(@completed, {
			timestamp => $key,
			complete => $sds{$key}->{COMPLETE},
			userid => $sds{$key}->{USERID},
			reason => $sds{$key}->{REASON},
		       });

    }

  }

  print "Processed arguments:\n";
  print Dumper(\@completed);

  if (!@completed) {
    $status->SetStatus(Dits::APP_ERROR);
    $status->ErsRep(0,"Attempting to mark MSB as completed but can not find any arguments to the action");
    addmessage($status,"Attempting to mark MSB as completed but can not find any arguments to the action");
    return $status;
  }

  # Now loop over all the timestamps
  for my $donemsb (@completed) {

    # First get the MSBID and PROJECTID
    my %details = get_msbcomplete_parameter_timestamp( $status,$donemsb->{timestamp});

    my $projectid = $details{PROJECTID};
    my $msbid     = $details{MSBID};
    my $msb       = $details{MSB};

    print "ProjectID: $projectid MSBID: $msbid TimeStamp: ".
      $donemsb->{timestamp}."\n";

    # Ooops if we have nothing
    if (!$msbid || !$projectid) {
        addmessage($status,"Attempting to mark MSB with timestamp ".$donemsb->{timestamp}." as complete but can no longer find it in the parameter system.");
	next;
    }

    my $mark = $donemsb->{complete};

    addmessage($status,"Attempting to mark MSB with timestamp ".$donemsb->{timestamp}." as complete Mark=$mark");

    if ($mark) {

      # Need to mark it as done [unless we are in simulate mode]
      OMP::MSBServer->doneMSB($projectid, $msbid, $donemsb->{userid},
			      $donemsb->{reason})
	  unless $SIM;

      addmessage($status,"MSB marked as done for project $projectid");

    } else {
      # file a comment to indicate that the MSB was rejected
      # unless we are in simulation mode
      OMP::MSBServer->rejectMSB( $projectid, $msbid, $donemsb->{userid},
				 $donemsb->{reason})
	  unless $SIM;

      addmessage($status,"MSB rejected for project $projectid");

    }

    # and clear the parameter
    clear_msbcomplete_parameter( $status, $donemsb->{timestamp} );

    # And remove the MSB from the queue
    if ($msb) {
      addmessage($status, "Removing completed MSB from queue");

      # Get an entry from the MSB
      my $entry = $msb->entries->[0];

      # Convert to an index
      if ($entry) {
	my $index = $QUEUE->contents->getindex( $entry );
	if (defined $index) {
	  # Cut it
	  $QUEUE->contents->cutmsb( $index );
	}
      }
    }

  }

  return $status;
}


=back

=begin __PRIVATE__

=head1 Internal Routines

These internal routines are used to simplify the individual actions by
grouping shared code. They are not in a stand-alone module simply
because the only program that currently needs these routines is this
program. They do not form part of the public interface.

=over 4

=item Sds_to_Entry

Converts an SDS structure into an array of C<Queue::Entry>
objects suitable for placing on the queue.

  @entries = Sds_to_Entry( $argid );

Currently assumes that the macro odf file name is in the sds structure
as Argument1. Can not yet accept the ODF itself as an SDS structure.

An optional argument can be used to indicate that the ODFs
correspond to CAL observations and should not be grouped
as MSBs. Default is to group into MSBs.

  @entries = Sds_to_entry( $argid, $iscal );

=cut

my $QUEUE_ID = 0;
sub Sds_to_Entry {
  my $argId = shift;
  my $iscal = shift;

  return unless defined $argId;

  # Need to check that we have a structure
  $argId->List(new DRAMA::Status);

  # tie the argId to a perl Hash
  my %sds;
  tie %sds, 'Sds::Tie', $argId;

  my $grp = new SCUBA::ODFGroup( File => $sds{Argument1});
  my @entries = map { new Queue::Entry::SCUBAODF("X", $_) } $grp->odfs;

  # Associate them with an MSB object
  # Note that this constructor associates itself with each
  # entry and so will not be destroyed when this $msb goes
  # out of scope.
  # If we are calibrations we do not want an MSB associations
  unless ($iscal) {
    my $msb = new Queue::MSB( entries => \@entries,
			      projectid => $entries[0]->projectid,
			      msbid => $entries[0]->msbid,
			    );

    # Register a completion handler
    $msb->msbcomplete( \&msbtidy );

    # Increment the global queue ID
    $QUEUE_ID++;

    # Store the Queue ID
    $msb->queueid( $QUEUE_ID );

  } else {
    # for queue id of 0
    for my $ent (@entries) {
      $ent->queueid( 0 );
    }
  }

  untie $argId;
  return @entries;
}


# PARAMETER MANIPULATION

=item B<update_contents_param>

Update the CONTENTS parameter

  update_contents_param( $status );

=cut

sub update_contents_param {
  return unless $_[0]->Ok;

  # Read the QUEUE parameter
  my $sds = $sdp->GetSds('Queue',$_[0]);
  return undef unless defined $sds;

  #$sds->List($_[0]);

  # Read the current queue contents
  # Note that the current contents will return an array containing
  # however many entries there are rather than the number of Queue
  # entries we have reserved
  my @Cur_contents = $QUEUE->contents->stringified;

  # Compare the current contents with the sds structure
  my $upd_con = compare_sds_to_perl($sds, 'Contents', \@Cur_contents, $_[0]);

  # If either of the update flags are true we should update
  my $update = 0;
  $update = 1 if $upd_con;

  # Notify the parameter system
  $sdp->Update($sds,$_[0]) if $update;

  # Clear any failure reasons if we have changed the Entries
  clear_failure_parameter($_[0]) if $update;

  # Check for the current value on the queue
  update_current_param($_[0]);

  # Update the time remaining
  update_time_remaining( $_[0] );

}

=item B<update_status_param>

Update the Stopped/Running flag using the STATUS parameter.

  update_status_param( $status );

The status argument is the DRAMA inherited status and not the
queue status.

=cut

sub update_status_param {
  my $status = shift;
  return unless $status->Ok;

  # Read the status parameter
  my $state = $sdp->GetString('STATUS',$status);

  # Read whether the Queue is running
  my $running = $QUEUE->backend->qrunning;

  # Only change the parameter if needed
  if ($state eq 'Running' && !$running) {
    $sdp->PutString('STATUS','Stopped',$status);
  } elsif ($state eq 'Stopped' && $running) {
    $sdp->PutString('STATUS','Running',$status);
  }

}

=item B<update_index_param>

Sync the index parameter with the queue

  update_index_param( $status );

=cut

sub update_index_param {
  my $status = shift;
  return unless $status->Ok;

  # Read the index parameter
  my $index = $sdp->Geti('INDEX',$status);

  # Get the queue value
  my $curindex = $QUEUE->contents->curindex;

  # Currently the parameter defaults to 0 if there are no entries
  $curindex = 0 unless defined $curindex;

  # Only change the parameter if needed
  if ($index != $curindex) {
    #print "::--+-+-+-+ SYNC index [$index/$curindex]\n";
    $sdp->Puti('INDEX', $curindex, $status);

    # Remember to change the local perl version. This lets
    # us know when the parameter was changed by external command
    $LOCAL_INDEX = $curindex;

    # Update the time remaining
    update_time_remaining( $status );

  }

}

=item B<update_time_remaining>

Update the time remaining parameter.

  update_time_remaining( $status );

=cut

sub update_time_remaining {
  my $status = shift;
  return unless $status->Ok;

  # Read the time parameter
  my $time = $sdp->Geti('TIMEONQUEUE',$status);

  # Get it from the queue
  my $qtime = int($QUEUE->contents->remaining_time->minutes);

  if ($qtime != $time) {
    $sdp->Puti( 'TIMEONQUEUE', $qtime, $status);
  }

}

=item B<verify_time_remaining>

Check whether the time remaining on the queue exceeds a
set threshold. Returns bad status if the threshold is exceeded.

  verify_time_remaining( $status );

The threshold is set to 40 minutes.

=cut

sub verify_time_remaining {
  my $status = shift;
  return unless $status->Ok;

  # Set the threshold
  my $TIME_THRESHOLD = 40.0;

  my $qtime = int($QUEUE->contents->remaining_time->minutes);

  if ($qtime > $TIME_THRESHOLD) {
    $status->SetStatus( Dits::APP_ERROR );
    $status->ErsRep(0, "The time remaining on the queue ($qtime minutes) exceeds the allowed threshold of $TIME_THRESHOLD. Please try again when the queue is smaller.");
  }

}


=item B<check_index_param_sync>

See if the queue index and parameter have changed independently
The LOCAL_INDEX variable helps us with this since we know it
can not be changed by an external prompt.

  check_index_param_sync( $status );

The correct way to do this may be to set up an internal monitor
on the parameter itself.

=cut

sub check_index_param_sync {
  my $status = shift;
  return unless $status->Ok;

  # Read the status parameter
  my $index = $sdp->Geti('INDEX',$status);

  # Get the queue value
  my $curindex = $QUEUE->contents->curindex;

  # Currently undef is not supported as a parameter value
  # so we change it to 0
  $curindex = 0 unless defined $curindex;

  # This means we should change the queue value if they are different
  # and if the parameter is not equal to the local cache
  # it is possible for the current index to be different to the 
  # parameter since the queue is updated asynchronously
  if ($index != $curindex && $index != $LOCAL_INDEX) {
    #print "+_+_+_+_+ Stopping queue due to index change [$index/$curindex]\n";
    $LOCAL_INDEX = $index;
    $QUEUE->contents->curindex( $index );
    &STOPQ($status);
    # Always clear if we have tweaked something
    clear_failure_parameter($status);

    # Update the time remaining
    update_time_remaining( $status );

  }

}

=item B<update_current_param>

Update the CURRENT parameter.

  update_current_param( $status );

The details of the entry currently being observed are obtained
via the global Queue object.

=cut

sub update_current_param {
  return unless $_[0]->Ok;

  # Read the CURRENT parameter
  my $curr = $sdp->GetString('CURRENT', $_[0]);

  # Read the last_sent to the backend
  my $last_sent = $QUEUE->backend->last_sent;

  # If nothing on set now to 'None'
  my $now;
  if (defined $last_sent) {
    $now = $last_sent->string;
  } else {
    $now = 'None';
  }

  # Compare
  if ($now ne $curr) {
    $sdp->PutString('CURRENT',$now,$_[0]);
  }

}

=item B<clear_failure_parameter>

Clear the contents of the failure parameter.
Arguments: inherited status

  clear_failure_parameter( $status );

=cut

sub clear_failure_parameter {
  my $status = shift;
  return unless $status->Ok;

  # Read the FAILURE parameter
  my $sds = $sdp->GetSds('FAILURE',$status);
  return undef unless defined $sds;

  # Now need to look for the DETAILS object
  # (use a private status)
  my $lstat = new DRAMA::Status;

  # it seems we have to trigger the update after the Sds structure
  # has been freed
  my $updated;
  {
    my $detsds = $sds->Find("DETAILS", $lstat);

    if ($detsds) {
      # if we have a DETAILS object we need to
      # configure it so that it is deleted when it goes out of scope
      $detsds->flags(1,1,1);

      $updated = 1;
    }
  }

  # and update the parameter
  $sdp->Update($sds,$status) if $updated;

  return;
}

=item B<set_failure_parameter>

Set the contents of the failure parameter.
Arguments: Inherited status, information hash

  set_failure_parameter( $status, %reason);

=cut

sub set_failure_parameter {
  my $status = shift;
  return unless $status->Ok;

  # Read the FAILURE parameter
  my $sds = $sdp->GetSds('FAILURE',$status);
  return undef unless defined $sds;

  # Read the arguments
  my %details = @_;

  # KLUGE - currently GetSds blesses the Sds into Arg class
  # This breaks PutHash since it *must* work on Sds objects
  # in order for the correct Create to be called. I think this
  # means that at the very leasy Sds.pm needs to use SUPER::Create
  # rather than just the Arg Create method. For now we rebless
  bless $sds, "Sds";

  # Add entries as strings
  $sds->PutHash( \%details, "DETAILS", $status);

  #$sds->List($status);

  # Notify the parameter system
  $sdp->Update($sds,$status);

  return;
}

=item B<set_msbcomplete_parameter>

Set the contents of the MSB complete parameter.  Arguments: Inherited
status, information hash This method takes the data (a hash of
information that should be sent to the monitoring system), timestamps
it and places it into the parameter. Use
C<clear_msbcomplete_parameter> to remove it. This allows us to stack
up MSB completion requests if we do not have a qmonitor running.

  set_msbcomplete_parameter( $status, %details)

Note that the MSB key is treated as a special case (the relevant
Queue::MSB object) and is not stored directly in the parameter.

=cut

my %MSBComplete;
sub set_msbcomplete_parameter {
  my $status = shift;
  return unless $status->Ok;

  # Read the MSBCOMPLETED parameter
  my $sds = $sdp->GetSds('MSBCOMPLETED',$status);
  return undef unless defined $sds;

  # Read the arguments
  my %details = @_;

  print Dumper(\%details);
  print ($status->Ok ? "status ok\n" : "status bad\n");

  # Generate a timestamp (not that it really needs to be
  # unique since Sds will handle it if we keep on adding
  # identical entries but they are hard to remove)
  my $tstamp = time();

  # The MSB object should not go in the SDS structure
  # so we store all this information in a hash outside
  # of it [that only the *_msbcomplete functions use -
  # this is essentially a Queue::MSBComplete object
  # Take a copy
  $MSBComplete{$tstamp} = { %details };

  # Remove the MSB field
  delete $details{MSB};

  # Add it to the parameter
  # standard kluge
  bless $sds, "Sds";

  # put in the inormation
  $sds->PutHash( \%details, "$tstamp", $status);

  $sds->List($status);

  # Notify the parameter system
  $sdp->Update($sds,$status);

  print "Get to the end of qcompleted param setting\n";
  return;
}

=item B<clear_msbcomplete_parameter>

Remove the completed information from the DRAMA parameter.

 clear_msbcomplete_parameter($status, $timestamp);

=cut

sub clear_msbcomplete_parameter {
  my $status = shift;
  return unless $status->Ok;

  # Read the MSBCOMPLETED parameter
  my $sds = $sdp->GetSds('MSBCOMPLETED',$status);
  return undef unless defined $sds;

  my $tstamp = shift;

  # Now need to look for the timestamp object
  # (use a private status)
  my $lstat = new DRAMA::Status;

  # Have to remove the old entries
  my $updated;
  {
    my $detsds = $sds->Find("$tstamp", $lstat);

    if ($detsds) {
      # if we have a DETAILS object we need to
      # configure it so that it is deleted when it goes out of scope
      $detsds->flags(1,1,1);

      # We are going to destroy it
      $updated = 1;

    }

  }

  # And we need to trigger a parameter update notification
  # if it was changed
  $sdp->Update($sds, $status) if $updated;

  # Clear the hash entry
  delete $MSBComplete{$tstamp};

  return;
}

=item B<get_msbcomplete_parameter_timestamp>

Retrieve the MSBID and Projectid information associated with the
supplied timestamp.  Simply returns the hash entry in %MSBComplete (the
pseudo C<Queue::MSBComplete> object)

 %details = get_msbcomplete_parameter_timestamp($status,$tstamp);

=cut

sub get_msbcomplete_parameter_timestamp {
  my $status = shift;
  return unless $status->Ok;
  my $tstamp = shift;

  if (exists $MSBComplete{$tstamp}) {
    return %{ $MSBComplete{$tstamp} };
  } else {
    return ();
  }

}

=item B<compare_sds_to_perl>

Sub to compare an SDS array with a perl array, updating the SDS array
if necessary. Arguments are an sds structure, the name of the
component in that structure that is to be compared, reference to a
reference perl array and inherited status:

  $changed = compare_sds_to_perl( $sdsid, $name, \@comp, $status);

Returns true if they were different, otherwise returns false.
This is used to decide whether a DRAMA parameter should have its
update state triggered for remote monitors (rather than sending
a monitor trigger every time we may have changed the Perl array).

=cut

sub compare_sds_to_perl ($$$$) {
  die 'Usage: compare_sds_to_perl($sds,$name,$arref,$status)'
    unless (scalar(@_) == 4 && ref($_[2]) eq 'ARRAY'
	    && UNIVERSAL::isa($_[0],'Sds'));

  return unless $_[3]->Ok;

  my $sds = shift;
  my $name = shift;
  my $arr = shift;

  # Read the named item from the Sds component
  my $csds = $sds->Find($name,$_[0]);
  my @sds_contents = $csds->GetStringArray($_[0]);

  # Process this array to remove trailing spaces (padding)
  # and shorten the array to match the size of the first
  # empty string - this will make the comparison more robust
  for my $i (0..$#sds_contents) {
    $sds_contents[$i] =~ s/\s+$//;
    if ($sds_contents[$i] eq '') {
      $#sds_contents = $i - 1;
      last;
    }
  }

  # This flag is used ro report a difference
  # Start by assuming no difference
  my $cur_diff = 0;

  # Since we have tidied the original array we can compare number of entries
  # directly
  # Making sure we remember that it is possible for the array to have
  # more than NENTRIES in it.
  if (scalar(@$arr) <= NENTRIES && scalar(@sds_contents) != scalar(@$arr)) {
    # Different number of elements
    $cur_diff = 1;
  } else {
    # Step through the current contents and compare with the
    # parameter contents
    for my $i (0..$#sds_contents) {
      # Need to retrieve the current value and trim
      # it if it is longer than the size of the SDS array
      # Take null character into account
      my $current = $arr->[$i];
      $current = substr($current,0,SZSTRING-1) if length($current) >= SZSTRING;

      # Also need to trim trailing space
      $current =~ s/\s+$//;
	
      # Now compare the sds and current entries
      if ($sds_contents[$i] ne $current) {
	$cur_diff = 1;
	last;
      }
    }
  }

  # Update the Contents array if they are different
  $csds->PutStringArrayExists($arr, $_[0]) if $cur_diff;

  # Return the cur_diff flag - true if we have updated
  return $cur_diff;
}


=item B<addmessage>

Given a message status and a message string, "publish"
that message as a parameter and simultaneously "print"
it using MsgOut. This method is useful for monitor
tasks that did not initiate the action that generates
the message.

  addmessage( $status, $text );

=cut

# Store messages in the parameter that is monitored
# takes status and text message
sub addmessage {
  my ($msgstatus, $msg) = @_;

  # trap for DRAMA status
  if (UNIVERSAL::can($msgstatus, "GetStatus")) {
    # extract the value of the status
    $msgstatus = $msgstatus->GetStatus;
  }

  my $status = new DRAMA::Status;
  my $sds = $sdp->GetSds('MESSAGES',$status);
  return undef unless defined $sds;

  # split messages on new lines
  my @lines = split(/\n/,$msg);

  # print them using MsgOut
  DRAMA::MsgOut($status, $msg);

  my $msgsds = $sds->Find('MESSAGE',$status);
  return unless defined $msgsds;
  my $stsds = $sds->Find('STATUS',$status);
  return unless defined $stsds;

  use PDL::Lite;
  $msgsds->PutStringArrayExists(\@lines,$status);
  $stsds->PutPdl(PDL::Core::pdl([$msgstatus]));
  $sdp->Update($sds,$status);
}

=item B<msbtidy>

This is the callback when the MSB queue finishes or if an MSB has been
cut whilst some of it has been observed.  all it needs to do is
extract the MSBID and set the completion parameter Passed either an
entry object or a C<Queue::MSB> object

=cut

sub msbtidy {
  my $object = shift;

  # Return immediately if we have no object
  return unless defined $object;

  # Now get the projectid and msbid
  my $projectid = $object->projectid;
  my $msbid = $object->msbid;

  # create a new drama status
  my $status = new DRAMA::Status;

  # What we really need is the Queue::MSB object so that we can
  # remove the MSB entries from the queue when it has been marked
  # as complete
  my $msb;
  if (UNIVERSAL::isa($object, "Queue::MSB")) {
    $msb = $object;
  } elsif (UNIVERSAL::isa($object,"Queue::Entry")) {
    $msb = $object->msb;
  }

  addmessage($status, "MSB contents fully observed");

  # If the MSB has not been observed at all then we do not
  # need to trigger anything here
  if ($msb && ! $msb->hasBeenObserved) {
    return;
  }

  # Since we are already processing an MSBCOMPLETE
  # we do not want to trigger another one
  # so disable the completion
  $msb->hasBeenObserved( 0 ) if $msb;

  # Collect the information we need to send the qmonitor
  # The REQUEST key is not really required since we never
  # set REQUEST to 0
  my %data;
  $data{REQUEST} = 1;
  $data{MSB}     = $msb;
  $data{QUEUEID} = $msb->queueid;
  $data{QUEUEID} = 0 unless defined $data{QUEUEID};

  # if we do not have an MSBID and project then we cant do anything else
  # so do not change the parameter
  if ($msbid && $projectid) {

    if ($projectid eq 'SCUBA' || $projectid =~ /JCMTCAL/ ) {
      addmessage($status, "Completed JCMT 'calibration' observations. No doneMSB");
      addmessage($status, "Project ID was $projectid");

    } elsif ($projectid eq 'UNKNOWN') {
      addmessage($status, "Unable to determine project ID. No doneMSB");

    } else {

      addmessage($status, "Possibility of marking MSB for project $projectid as done [MSB=$msbid]");

      # Store it
      $data{MSBID} = $msbid;
      $data{PROJECTID} = $projectid;

      # And now store it in the parameter
      set_msbcomplete_parameter($status, %data);

    }

  } else {
    my $msg = "Queue contents fully observed but no MSBID or PROJECTID available.";
    addmessage($status, $msg)
  }
}


=back

=end __PRIVATE__

=head1 SEE ALSO

L<Queue::Contents>, L<qmonitor>

=head1 AUTHOR

Tim Jenness, E<lt>t.jenness@jach.hawaii.eduE<gt>

Copyright (C) Particle Physics and Astronomy Research Council
1999-2002. All Rights Reserved.

=cut
